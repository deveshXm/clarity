---
description: Follow this rule while making changes in db schema.
globs: src/lib/**/*.ts,src/types/**/*.ts,src/app/api/**/*.ts
---

# Database Design & Server Actions Rules

## Operational Guidelines

- Do not run builds unless explicitly asked
  - Avoid `npm run build` during iterative edits; rely on type checks/lint where needed.

- GSAP is available (FYI)
  - The project has `gsap` installed for UI work. It is irrelevant for database code; do not add animation deps.

## Architecture (MongoDB Native Driver)

- Use the native MongoDB driver via the shared client at [src/lib/db.ts](mdc:src/lib/db.ts); do not introduce ODM/ORM layers.
- Database name must come from `process.env.MONGODB_DB_NAME`.
- All database mutations and reads should live in Server Actions in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts).
- Validate all inputs with Zod schemas from [src/types/index.ts](mdc:src/types/index.ts) before performing DB operations.

## Patterns

- Collections: keep workspace-scoped data keyed by workspace identifiers; store Slack workspace `botToken` on the workspace record.
- Avoid over-normalization; prefer simple documents with clear ownership and indexing.
- Use explicit TypeScript types inferred from Zod schemas; never use `any`.
- When adding fields, prefer additive, backward-compatible changes; write guards for optional legacy fields.
- **Email Field**: User email is nullable in schema, defaults to `null` for new users, collected during onboarding

## ObjectId Consistency Rules ‚úÖ CRITICAL
- **Always use ObjectId directly**: Store MongoDB ObjectIds as ObjectId type, not strings
- **Query with ObjectId**: When querying by userId, use `user._id` directly, not `user._id.toString()`
- **Analysis Instance Pattern**:
  ```typescript
  // ‚úÖ CORRECT - Store ObjectId directly
  await analysisInstanceCollection.insertOne({
    _id: new ObjectId(),
    userId: user._id, // ObjectId directly
    workspaceId: user.workspaceId,
    // ... other fields
  });
  
  // ‚úÖ CORRECT - Query with ObjectId directly  
  const instances = await analysisInstanceCollection.find({
    userId: user._id, // Query with ObjectId directly
    createdAt: { $gte: startDate }
  }).toArray();
  
  // ‚ùå WRONG - String conversion causes query mismatches
  userId: user._id.toString() // Don't convert to string
  userId: validatedEvent.user  // Don't use Slack ID
  ```
- **Type Schema**: Use `z.instanceof(ObjectId)` in Zod schemas for ObjectId fields
- **Data Consistency**: Ensures perfect query matching between storage and retrieval operations

## User Lifecycle Management ‚úÖ ENHANCED

- **Never delete users or workspaces** - use `isActive: boolean` field for deactivation
- **Install/Reinstall Flow**: Set `isActive: true` and overwrite all values except usage data
- **Uninstall Flow**: Set `isActive: false`, preserve all user data, and clean up botChannels collection
- **Prevents Usage Abuse**: Users can't reset limits by uninstalling/reinstalling

### Reinstallation Behavior ‚úÖ UPDATED
- **Fresh Start**: All preferences, settings, and onboarding status reset to defaults
- **Usage Protection**: Monthly usage counters and subscription data preserved
- **Complete Overwrite**: Profile, settings, channel preferences, onboarding status reset
- **OAuth Callback Pattern**:
  ```typescript
  const existingUser = await slackUserCollection.findOne({ slackId, workspaceId });
  if (existingUser) {
    // Preserve usage but overwrite everything else
    const preservedUsage = existingUser.subscription?.monthlyUsage;
    const updatedSubscription = {
      ...defaultSubscription,
      monthlyUsage: preservedUsage, // Keep usage data
      tier: existingUser.subscription?.tier || 'FREE', // Keep subscription tier
      stripeCustomerId: existingUser.subscription?.stripeCustomerId, // Keep Stripe data
    };
    
    await slackUserCollection.updateOne(
      { slackId, workspaceId },
      { 
        $set: { 
          // Overwrite ALL fields except usage
          isActive: true,
          email: null, // Reset email - user must provide during onboarding
          analysisFrequency: 'weekly', // Reset to default
          autoCoachingEnabledChannels: [], // Reset channel preferences (disabled by default)  
          hasCompletedOnboarding: false, // Reset onboarding
          subscription: updatedSubscription, // Preserve usage, reset other settings
          // ... all other fields reset to defaults
        }
      }
    );
  }
  ```

### Uninstallation Cleanup ‚úÖ ENHANCED
- **App Uninstall Handler**: Listen for `app_uninstalled` and `tokens_revoked` events in [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts)
- **Complete Cleanup**: `handleAppUninstall(teamId)` function now:
  - Deactivates all workspace users (`isActive: false`)
  - Deactivates workspace (`isActive: false`) 
  - **NEW**: Removes all entries from `botChannelsCollection` for the workspace
  - **NEW**: Tracks uninstallation analytics with user/channel counts
- **Channel Cleanup**: `botChannelsCollection.deleteMany({ workspaceId })` removes stale channel references
- **Analytics Tracking**: `API_SLACK_APP_UNINSTALLED` event tracks deactivation metrics
- **Manifest Events Required**: Add both `app_uninstalled` and `tokens_revoked` to bot_events in manifest files

## Slack Tokens & Access

- Never use a global Slack bot token. Always look up the workspace-specific token from the database.
- Keep channel access checks in server actions, not client components.

## Testing & Migrations

- Keep migrations minimal and reversible. For complex changes, write idempotent migration steps in a dedicated script (ask before adding files).
- Do not create new files without explicit approval in this project; co-locate light migration helpers in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) when necessary.
---
description: Follow this rule while making changes in db schema.
alwaysApply: false
---
# Database Design Patterns

## Collection Separation Strategy

### Generic Boilerplate Collections
```typescript
// Core collections for boilerplate
User {
  _id: string,
  id: string,
  email: string,
  name: string,
  image?: string,
  emailVerified: boolean,
  hasCompletedOnboarding?: boolean,
  createdAt: Date,
  updatedAt: Date
}

AccountConfig {
  _id: string,
  userId: string,
  companyName: string,
  websiteUrl?: string,
  createdAt: Date,
  updatedAt: Date
}
```

## Database Configuration

### Collections Setup
**Location**: [src/lib/db.ts](mdc:src/lib/db.ts)

```typescript
// Core collections
export const userCollection = db.collection("user")
export const accountConfigCollection = db.collection("accountConfig")

// Slack-specific collections
export const workspaceCollection = db.collection("workspaces")
export const slackUserCollection = db.collection("slackUsers")
export const botChannelsCollection = db.collection("botChannels")
export const invitationCollection = db.collection("invitations")
export const analysisInstanceCollection = db.collection("analysisInstances")
export const reportCollection = db.collection("reports")
export const feedbackCollection = db.collection("feedback")
```

### Naming Convention
- **Database**: Use `process.env.MONGODB_DB_NAME` (configurable)
- **Collections**: camelCase names
- **Application**: Generic names like "Your App"

### Slack-Specific Collections

```typescript
// Workspace with bot token for API calls
Workspace {
  _id: ObjectId,
  workspaceId: string,     // Slack team ID (T08HU2MKRK2)
  name: string,
  domain?: string,
  botToken: string,        // Workspace-specific bot token from OAuth
  createdAt: Date,
  updatedAt: Date
}

// Bot channel tracking for access control
BotChannel {
  _id: ObjectId,
  workspaceId: string,     // User's workspace ObjectId (relationship key)
  channelId: string,       // Slack channel ID
  channelName: string,     // Display name
  addedAt: Date
}

// Slack user linked to workspace
SlackUser {
  _id: ObjectId,
  slackId: string,         // Slack user ID
  workspaceId: string,     // References workspace ObjectId
  analysisFrequency: 'weekly' | 'monthly',
  autoCoachingEnabledChannels: string[],   // Channel IDs where auto-coaching is enabled (default: empty array = disabled everywhere)
  hasCompletedOnboarding: boolean,         // ‚úÖ CRITICAL: Feature access control
  subscription: SubscriptionSchema,        // Includes usage tracking and tier info
  // ... other user fields
}
```

**Onboarding Field Usage:**
- **Default Value**: `false` for new users
- **Feature Gate**: All commands and auto-coaching check this field
- **User Experience**: Clean onboarding prompts when `false`
- **Analytics**: Tracked when users hit onboarding barriers

## Onboarding Analytics & Tracking ‚úÖ IMPLEMENTED

### Event Type Integration
**New Event:** `limits:onboarding_required`

**Database Schema Impact:**
- **No Schema Changes**: Uses existing `hasCompletedOnboarding` boolean field
- **Analytics Collection**: Events stored in PostHog with rich metadata
- **Query Patterns**: Aggregate by user, workspace, subscription tier, and feature

### Tracking Implementation Patterns

**Command Handler Tracking:**
```typescript
// Track when users hit onboarding barriers via commands
const requiresOnboarding = ['/clarity-personal-feedback', '/clarity-rephrase', '/clarity-settings', '/clarity-feedback'].includes(command);
if (requiresOnboarding && !appUser.hasCompletedOnboarding) {
  trackEvent(userId, EVENTS.LIMITS_ONBOARDING_REQUIRED, {
    command: command,
    channel_id: channelId,
    user_name: appUser.name,
    workspace_id: appUser.workspaceId,
    subscription_tier: appUser.subscription?.tier || 'FREE',
  });
}
```

**Auto Coaching Tracking:**
```typescript
// Track when auto coaching is skipped due to onboarding
if (!user.hasCompletedOnboarding) {
  trackEvent(validatedEvent.user, EVENTS.LIMITS_ONBOARDING_REQUIRED, {
    command: 'auto_coaching',
    channel_id: validatedEvent.channel,
    user_name: user.name,
    workspace_id: user.workspaceId,
    subscription_tier: user.subscription?.tier || 'FREE',
    message_length: validatedEvent.text.length,
  });
  return; // Skip processing
}
```

### Analytics Query Patterns

**Onboarding Barrier Analysis:**
```typescript
// Find users hitting onboarding barriers most frequently
const barrierAnalysis = await slackUserCollection.aggregate([
  {
    $lookup: {
      from: 'posthog_events', // Assuming events are in PostHog
      let: { userId: { $toString: '$_id' } },
      pipeline: [
        {
          $match: {
            $expr: {
              $and: [
                { $eq: ['$user_id', '$$userId'] },
                { $eq: ['$event_type', 'limits:onboarding_required'] }
              ]
            }
          }
        }
      ],
      as: 'barrier_events'
    }
  },
  {
    $match: {
      'barrier_events.0': { $exists: true },
      hasCompletedOnboarding: false
    }
  },
  {
    $project: {
      slackId: 1,
      name: 1,
      workspaceId: 1,
      subscription: 1,
      barrier_count: { $size: '$barrier_events' },
      first_barrier: { $min: '$barrier_events.timestamp' },
      last_barrier: { $max: '$barrier_events.timestamp' }
    }
  },
  {
    $sort: { barrier_count: -1 }
  }
]);
```

**Feature Demand by Tier:**
```typescript
// Understand which features users want by subscription tier
const featureDemand = await slackUserCollection.aggregate([
  {
    $lookup: {
      from: 'posthog_events',
      let: { userId: { $toString: '$_id' } },
      pipeline: [
        {
          $match: {
            $expr: {
              $and: [
                { $eq: ['$user_id', '$$userId'] },
                { $eq: ['$event_type', 'limits:onboarding_required'] }
              ]
            }
          }
        },
        {
          $group: {
            _id: '$properties.command',
            count: { $sum: 1 },
            unique_users: { $addToSet: '$user_id' }
          }
        }
      ],
      as: 'features_attempted'
    }
  },
  {
    $match: {
      'features_attempted.0': { $exists: true }
    }
  },
  {
    $group: {
      _id: '$subscription.tier',
      total_barriers: { $sum: { $size: '$features_attempted' } },
      features: {
        $push: {
          feature: '$features_attempted._id',
          attempts: '$features_attempted.count',
          unique_users: { $size: '$features_attempted.unique_users' }
        }
      }
    }
  }
]);
```

### Business Intelligence Insights

**Conversion Funnel Analysis:**
- **Barrier Identification**: Track where users get stuck in onboarding
- **Feature Demand**: Understand which features drive onboarding completion
- **Tier Migration**: See how PRO users differ from FREE users in barrier patterns
- **Time-based Patterns**: Identify peak times for onboarding attempts

**User Segmentation:**
- **Power Users**: Users who hit many barriers before completing onboarding
- **Quick Adopters**: Users who complete onboarding quickly
- **Feature Seekers**: Users who specifically seek certain features
- **Subscription Candidates**: FREE users hitting PRO feature barriers frequently

### Database Performance Considerations

**Index Recommendations:**
```javascript
// Optimize for onboarding analytics queries
db.slackUsers.createIndex({ hasCompletedOnboarding: 1 });
db.slackUsers.createIndex({ 'subscription.tier': 1 });
db.slackUsers.createIndex({
  hasCompletedOnboarding: 1,
  'subscription.tier': 1
});

// PostHog events (if stored locally)
db.posthog_events.createIndex({ user_id: 1, event_type: 1 });
db.posthog_events.createIndex({ timestamp: -1 });
```

**Query Optimization:**
- **Event Caching**: Cache frequently accessed analytics data
- **Batch Processing**: Process analytics aggregations in background jobs
- **Archive Strategy**: Move old events to archive collections for performance

## Slack Event Handling & Auto Coaching Patterns

### 1. Event Subscription Requirements ‚úÖ CRITICAL
**Bot only receives events from channels where it's a member:**

```typescript
// Slack sends message.channels events ONLY from:
// 1. Channels where bot is explicitly added
// 2. Channels bot joined via conversations.join API
// 3. NOT from all public channels (privacy protection)

// Manifest.json event subscriptions required:
"bot_events": [
  "message.channels",      // Public channel messages (REQUIRED for auto coaching)
  "message.groups",        // Private channel messages
  "member_joined_channel", // Bot joins channels (updates database + sends notifications)
  "channel_left",          // Bot leaves public channels (updates database)
  "group_left",           // Bot leaves private channels/groups (updates database)
  "app_mention"           // @bot mentions
]
```

### 2. Channel Access Control Pattern ‚úÖ IMPLEMENTED
**Double-layer security for message processing:**

```typescript
// Layer 1: Slack's membership filter (automatic)
// Layer 2: Our database verification (kept in sync via events)
const isChannelActive = await botChannelsCollection.findOne({
  channelId: slackChannelId,
  workspaceId: userWorkspaceObjectId  // User's workspace reference
})

if (!isChannelActive) {
  console.log('‚è≠Ô∏è Bot not active in this channel, skipping analysis');
  return; // Skip processing - bot not authorized
}
```

### 3. Optimized Auto Coaching Flow ‚úÖ UPDATED
**Single AI call comprehensive analysis pipeline:**

```typescript
// Step 1: Receive message event (only from member channels)
if (event.type === 'message' && (event.channel_type === 'channel' || event.channel_type === 'group')) {
  
  // Step 2: Validate user has app installed and check per-channel auto-coaching
  const user = await slackUserCollection.findOne({ 
    slackId: event.user, 
    isActive: true 
  });
  if (!user) return;
  
  // Step 2.5: Check if auto-coaching is disabled for this specific channel
  if (!user.autoCoachingEnabledChannels.includes(event.channel)) return;
  
  // Step 3: Check bot is active in this specific channel
  const isChannelActive = await isChannelAccessible(event.channel, user.workspaceId);
  if (!isChannelActive) return; // Skip - not authorized channel
  
  // Step 4: Get workspace-specific bot token
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  if (!workspace?.botToken) return; // Skip - missing token
  
  // Step 5: Always fetch conversation history for better context
  const conversationHistory = await fetchConversationHistory(event.channel, workspace.botToken, event.ts, 15);
  
  // Step 6: Single comprehensive AI analysis (replaces 4 separate AI calls)
  const analysis = await comprehensiveMessageAnalysis(event.text, conversationHistory);
  
  // Step 7: Send ephemeral coaching feedback if needed (private to user)
  if (analysis.needsCoaching && analysis.flags.length > 0 && analysis.improvedMessage) {
    // Send interactive Block Kit message with improved version
  }
}
```

### 4. Command Authorization Pattern ‚úÖ SIMPLIFIED
**Simple database presence check for command access:**

```typescript
// Check if user exists in database (authorized via website)
const appUser = await slackUserCollection.findOne({
  slackId: userId,
  isActive: true
});

if (!appUser) {
  // User not in database - show authorization message
  const { getSlackOAuthUrl } = await import('@/lib/slack');
  const authUrl = getSlackOAuthUrl();
  
  return NextResponse.json({
    text: 'ü§ó Welcome to Clarity! Before I help you write effortlessly, I need you to authorize. Simply click the button below.',
    response_type: 'ephemeral',
    blocks: [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: 'ü§ó *Welcome to Clarity!* Before I help you write effortlessly, I need you to authorize. Simply click the button below.'
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Authorize with Website',
              emoji: true
            },
            url: authUrl,
            action_id: 'authorize_website'
          }
        ]
      }
    ]
  });
}
```

### 5. Slack Commands Implementation ‚úÖ CURRENT
**Available commands in [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts):**

```typescript
// Command routing in switch statement - ALL commands use clarity- prefix
switch (command) {
  case '/clarity-help':
    response = await handleClarityHelp();
    break;
  case '/clarity-personal-feedback':  // ‚úÖ Updated with clarity- prefix
    response = await handlePersonalFeedback(userId, channelId);
    break;
  case '/clarity-rephrase':  // ‚úÖ Updated with clarity- prefix
    response = await handleRephrase(text, userId, channelId);
    break;
  case '/clarity-settings':  // ‚úÖ Updated with clarity- prefix
    response = await handleSettings(text, userId, appUser as unknown as SlackUser, triggerId!);
    break;
  case '/clarity-status':  // ‚úÖ NEW: Channel status checking
    response = await handleClarityStatus(userId, channelId, appUser as unknown as SlackUser);
    break;
  case '/clarity-feedback':  // ‚úÖ NEW: User feedback submission
    response = await handleFeedback(text, userId, appUser as unknown as SlackUser);
    break;
}
```

**Help Command Pattern:**
```typescript
// /clarity-help - 2x2 grid layout with help button
async function handleClarityHelp() {
  return {
    text: 'Clarity Help',
    response_type: 'ephemeral',
    blocks: [
      {
        type: 'header',
        text: { type: 'plain_text', text: 'Clarity Help' }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: '_Show all available Clarity commands and features_\n\n`/clarity-help`'
          },
          {
            type: 'mrkdwn', 
            text: '_Rephrase your original text for clarity or variation_\n\n`/rephrase your_original_text`'
          }
        ]
      },
      // ... more command rows
      {
        type: 'section',
        text: { type: 'mrkdwn', text: '*Need more help?*' },
        accessory: {
          type: 'button',
          text: { type: 'plain_text', text: 'View Guide', emoji: true },
          style: 'primary',
          url: `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/app/help`
        }
      }
    ]
  };
}
```

**Status Command Pattern ‚úÖ NEW:**
```typescript
// /clarity-status - Channel status checking with visual indicators
async function handleClarityStatus(userId: string, channelId: string, user: SlackUser) {
  // 1. Channel type detection using ID prefixes
  if (!channelId.startsWith('C') && !channelId.startsWith('G')) {
    return {
      text: 'Please use this command in a channel to check Clarity\'s status.',
      response_type: 'ephemeral'
    };
  }

  // 2. Check bot installation using existing isChannelAccessible function
  const isChannelActive = await isChannelAccessible(channelId, user.workspaceId);
  
  if (!isChannelActive) {
    return {
      text: 'üî¥ Clarity is not installed in this channel.',
      response_type: 'ephemeral'
    };
  }

  // 3. Check per-channel auto-coaching settings
  const isAutoCoachingEnabled = user.autoCoachingEnabledChannels.includes(channelId);
  
  if (!isAutoCoachingEnabled) {
    return {
      text: 'üü° Clarity is installed but auto coaching is not enabled in this channel.',
      response_type: 'ephemeral'
    };
  }

  // 4. Fully active status
  return {
    text: 'üü¢ Clarity is installed and monitoring this channel for auto coaching.',
    response_type: 'ephemeral'
  };
}
```

**Status Detection Logic:**
- **Channel Types**: `C` (public), `G` (private), `D` (DM) - only work in channels
- **Bot Installation**: Uses `isChannelAccessible()` to check `botChannelsCollection`
- **Auto-Coaching Status**: Checks `user.autoCoachingEnabledChannels` array
- **Visual Indicators**: üî¥ (not installed), üü° (not enabled), üü¢ (active)

**Feedback Command Pattern ‚úÖ NEW:**
```typescript
// /clarity-feedback [text] - User feedback submission
async function handleFeedback(text: string, userId: string, user: SlackUser) {
  if (!text.trim()) {
    return {
      text: 'Please provide your feedback. Example: `/clarity-feedback I love this feature!`',
      response_type: 'ephemeral'
    };
  }

  // Store in database
  await feedbackCollection.insertOne({
    _id: new ObjectId(),
    slackId: userId,
    workspaceId: user.workspaceId,
    userName: user.name,
    text: text.trim(),
    subscriptionTier: user.subscription?.tier || 'FREE',
    createdAt: new Date()
  });

  // Track in PostHog
  trackEvent(userId, EVENTS.FEATURE_FEEDBACK_SUBMITTED, {
    user_name: user.name,
    workspace_id: user.workspaceId,
    subscription_tier: user.subscription?.tier || 'FREE',
    feedback_length: text.trim().length,
  });

  return {
    text: '‚úÖ *Thank you for your feedback!*\n\nWe appreciate you taking the time to share your thoughts.',
    response_type: 'ephemeral'
  };
}
```

**Feedback Collection Schema:**
```typescript
Feedback {
  _id: ObjectId,
  slackId: string,         // Slack user ID
  workspaceId: string,     // References workspace ObjectId
  userName: string,        // User's display name
  text: string,            // Feedback content
  subscriptionTier: string, // FREE or PRO
  createdAt: Date
}
```

## Query Patterns

### 1. User Validation
**Always validate before data access:**

```typescript
// Standard pattern in server actions
const user = await userCollection.findOne({
  _id: new ObjectId(userId)
})

if (!user) {
  return { success: false, error: 'User not found' }
}
```

### 2. Account Config Fetching
**After user validation:**

```typescript
const accountConfig = await accountConfigCollection.findOne({ 
  userId: userId 
})

// Always serialize MongoDB _id to string
const serializedConfig = accountConfig ? {
  ...accountConfig,
  _id: accountConfig._id.toString()
} : null
```

### 3. Workspace Token Lookup Pattern ‚úÖ CRITICAL
**For Slack API calls with workspace-specific tokens:**

```typescript
// Get workspace by Slack team ID
const workspace = await workspaceCollection.findOne({ 
  workspaceId: teamId  // Slack team ID like T08HU2MKRK2
})

// Get workspace by user's workspace ObjectId
const workspace = await workspaceCollection.findOne({ 
  _id: new ObjectId(userWorkspaceId) 
})

if (!workspace || !workspace.botToken) {
  return { error: 'Workspace not found or missing bot token' }
}

// Use workspace-specific token for API calls
const workspaceSlack = new WebClient(workspace.botToken)
```

### 4. Channel Access Control Pattern
**Check if bot is active in channel:**

```typescript
const isChannelActive = await botChannelsCollection.findOne({
  channelId: slackChannelId,
  workspaceId: userWorkspaceObjectId  // User's workspace reference
})

if (!isChannelActive) {
  // Skip processing - bot not active in this channel
  return
}
```

### 5. Bot Channel Management Pattern ‚úÖ EVENT-DRIVEN ARCHITECTURE
**Event-driven channel membership tracking:**

```typescript
// Onboarding: Only join channels (events handle database)
for (const channel of selectedChannels) {
  const joinSuccess = await joinChannel(channel.id, workspace.botToken);
  
  if (joinSuccess) {
    // member_joined_channel event will update botChannelsCollection automatically
    console.log(`‚úÖ Bot joined channel: ${channel.name}`);
  }
}

// Event handlers in /api/slack/events/route.ts
async function handleBotJoinedChannel(event) {
  // Verify it's our bot joining
  const botUserId = await slack.auth.test().user_id;
  if (event.user !== botUserId) return;
  
  // Add to database
  await botChannelsCollection.insertOne({
    _id: new ObjectId(),
    workspaceId: workspace._id.toString(),
    channelId: event.channel,
    channelName: channelInfo.name,
    addedAt: new Date()
  });
  
  // Send notification to workspace users about new channel monitoring
  await notifyUsersAboutNewChannelMonitoring(workspace, event.channel, channelInfo.name);
}

async function handleBotLeftChannel(event, teamId) {
  // No bot verification needed - channel_left/group_left events are bot-specific
  // Remove from database when bot leaves
  await botChannelsCollection.deleteOne({
    channelId: event.channel,
    workspaceId: workspace._id.toString()
  });
}
```

**Key Benefits:**
- **Single Source of Truth**: Slack events drive ALL channel membership changes
- **Manual Addition Support**: Users can add bot to channels after onboarding
- **Automatic Sync**: Database always reflects actual bot membership
- **No Race Conditions**: Events ensure consistency between Slack and database

## Type System Integration

### Schema Location
**All schemas in**: [src/types/index.ts](mdc:src/types/index.ts)

### Pattern: Schema ‚Üí Type Inference
```typescript
// 1. Define Zod schema first
export const AccountConfigSchema = z.object({
  _id: z.string(),
  userId: z.string(),
  companyName: z.string().min(1),
  websiteUrl: z.string().url().optional(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
})

// 2. Infer TypeScript type
export type AccountConfig = z.infer<typeof AccountConfigSchema>

// 3. Create input schema (omit auto-generated fields)
export const CreateAccountConfigSchema = AccountConfigSchema.omit({ 
  _id: true, 
  createdAt: true, 
  updatedAt: true 
})

export type CreateAccountConfigInput = z.infer<typeof CreateAccountConfigSchema>
```

### Slack Event Validation
```typescript
// Validate incoming Slack events
export const SlackEventSchema = z.object({
  type: z.literal('message'),
  user: z.string(),
  text: z.string(),
  channel: z.string(),
  ts: z.string(),
  channel_type: z.enum(['channel', 'group'])
});
```

## Data Consistency Patterns

### 1. Timestamp Handling
**Use millisecond epoch timestamps for all date fields:**

```typescript
// Import the utility function
import { getNowTimestamp } from '@/lib/utils';

// Use for all date fields
const now = getNowTimestamp(); // Returns millisecond epoch timestamp

// Example usage in database operations
await accountConfigCollection.insertOne({
  ...data,
  createdAt: now,
  updatedAt: now
});
```

### 2. Status Management
**Consistent status patterns:**

```typescript
type Status = "pending" | "completed" | "failed"

// Example for future task implementations
task.status = "pending" ‚Üí "completed"
```

## Security Patterns

### 1. User Isolation
**Always filter by userId:**

```typescript
// Account config access
{ userId: user.id }

// Always verify ownership before operations
const config = await accountConfigCollection.findOne({ 
  _id: new ObjectId(configId),
  userId: user.id 
})
```

### 2. Data Serialization
**Always convert ObjectId to string:**

```typescript
const serializedConfig: AccountConfig = {
  _id: config._id.toString(), // ‚úÖ Convert ObjectId
  userId: config.userId,
  companyName: config.companyName,
  websiteUrl: config.websiteUrl,
  createdAt: config.createdAt,
  updatedAt: config.updatedAt
}
```

### 5. Slack Privacy Protection ‚úÖ SIMPLIFIED
**Multi-layer privacy safeguards:**

```typescript
// Layer 1: Slack only sends events from channels where bot is member
// Layer 2: Our database tracks authorized channels only
// Layer 3: User must exist in database (authorized via website)
// Layer 4: Ephemeral messages are private (only sender sees feedback)

// Privacy by design:
// - No message storage (only analysis results)
// - User controls which channels to enable
// - Coaching feedback is private and ephemeral
// - Simple authorization: user in database = authorized
```

## AI Architecture Optimizations ‚úÖ UPDATED

### 1. Single AI Call Auto-Coaching
**Optimized from 4 AI calls to 1 comprehensive call:**

```typescript
// OLD APPROACH (4 separate AI calls):
// 1. quickCheckNeedsCoaching(message) ‚Üí AI Call #1
// 2. analyzeMessageForFlags(message, context) ‚Üí AI Call #2  
// 3. generateImprovedMessage(message, flagType) ‚Üí AI Call #3
// 4. identifyMessageTarget(message, context) ‚Üí AI Call #4

// NEW APPROACH (1 comprehensive AI call with target resolution):
const analysis = await comprehensiveMessageAnalysis(message, conversationHistory);
// Returns: { needsCoaching, flags, targetIds, improvedMessage, reasoning }
```

### 2. Target Resolution Architecture ‚úÖ NEW
**Store IDs during analysis, resolve names during reporting:**

```typescript
// üéØ Analysis Phase (Real-time) - Store only IDs
await analysisInstanceCollection.insertOne({
    userId: validatedEvent.user,
    workspaceId: user.workspaceId,
    channelId: validatedEvent.channel,
    messageTs: validatedEvent.ts,
    text: validatedEvent.text,
    flagIds: analysis.flags.map(f => f.typeId),
    targetIds: analysis.targetIds || [], // üéØ Multiple target user IDs
    createdAt: new Date(),
});

// üìä Report Generation Phase - Resolve names dynamically
const allTargetIds = new Set<string>();
currentInstances.forEach(instance => {
    const targetIds = instance.targetIds || [];
    targetIds.forEach((id: string) => allTargetIds.add(id));
});

const resolvedUserNames = await resolveSlackUserNames(
    Array.from(allTargetIds), 
    workspace.botToken
);

const partnerAnalysis = await analyzeCommunicationPartners(
    currentInstances, 
    resolvedUserNames
);
```

### 3. GPT-5 Prompting Best Practices ‚úÖ UPDATED
**Enhanced target identification and tone adaptation:**

```typescript
// Target identification guidelines:
// - Extract Slack user IDs from @mentions: <@U123456> or <@U123456|username>
// - Identify implicit targets from conversation flow and replies
// - Return targetIds array with valid Slack user IDs starting with 'U'
// - Support multiple targets per message

// Prompt guidelines for improved messages:
// - Match the user's tone, register, and formality
// - Keep approximately the same length unless brevity helps
// - Preserve Slack specifics: @mentions, <#channel> references, links, code
// - Avoid AI-ish phrasing, hedging, or generic filler
// - Sound human and natural - like the same person wrote it, just better

// Required JSON Response Format:
{
  "needsCoaching": true/false,
  "flags": [{"typeId": 1, "type": "pushiness", "confidence": 0.8, "explanation": "reason"}],
  "targetIds": ["U123456789", "U987654321"] or [],
  "improvedMessage": {...} or null,
  "reasoning": {...}
}
```

### 4. Performance Gains ‚úÖ ENHANCED
- **Speed**: ~75% faster response times (1 AI call vs 4)
- **Cost**: ~75% reduction in API costs
- **Accuracy**: Better analysis with full context always available
- **Reliability**: Fewer API calls = fewer potential failure points
- **Target Resolution**: No real-time Slack API calls during message analysis
- **Report Performance**: Bulk user resolution with parallel API calls
- **Fresh Data**: Always current display names in reports
- **Multiple Targets**: Support for messages directed to multiple people

### 4. Azure OpenAI Configuration
**Optimized for speed with low reasoning effort:**

```typescript
// src/lib/ai.ts configuration
const response = await openaiClient.chat.completions.create({
  messages,
  model: modelName,
  reasoning_effort: 'low', // Optimized for speed
  response_format: { type: 'json_object' },
});
```

## Performance Optimizations

### 1. Document Size Limits
- **User documents**: Minimal, essential auth data only
- **Account config documents**: Simple configuration data
- **Query efficiency**: Direct access without complex joins

### 2. Index Recommendations (Future)
```javascript
// Recommended indexes for production:
db.user.createIndex({ "email": 1 })
db.user.createIndex({ "id": 1 })
db.accountConfig.createIndex({ "userId": 1 })

// Slack-specific indexes
db.slackUsers.createIndex({ "slackId": 1 })
db.workspaces.createIndex({ "workspaceId": 1 })
db.botChannels.createIndex({ "channelId": 1, "workspaceId": 1 })
```

### 3. Query Optimization
- **Batch operations**: Use `insertMany()` for multiple records
- **Selective fetching**: Only query data when needed
- **User validation**: Fail fast on ownership checks

## Migration Strategy

### What Was Removed (Boilerplate Cleanup)
- ‚ùå Creative-related collections and schemas
- ‚ùå Complex account configuration fields
- ‚ùå AI-specific data structures
- ‚ùå Image and media collections

### What Was Added
- ‚úÖ Simplified user and account config collections
- ‚úÖ Generic account configuration schema
- ‚úÖ Basic onboarding flow data
- ‚úÖ Clean, minimal database structure
- ‚úÖ Slack-specific collections for bot management
- ‚úÖ Workspace token storage and channel access control

### Data Migration Notes
**For boilerplate**: No migration needed - clean slate
**For production data**: Would need custom migration scripts based on specific requirements

## Utility Functions

### Timestamp Utility
**Location**: [src/lib/utils.ts](mdc:src/lib/utils.ts)

```typescript
// Use this function for all timestamp fields
export const getNowTimestamp = (): number => {
  return Date.now(); // Returns millisecond epoch timestamp
};
```

**Usage in database operations:**
```typescript
import { getNowTimestamp } from '@/lib/utils';

// Always use this for timestamps
const now = getNowTimestamp();

await collection.insertOne({
  ...data,
  createdAt: now,
  updatedAt: now
});
```

## Example Implementation

### Server Action Pattern
```typescript
export async function upsertAccountConfig(rawData: AccountConfigFormData): Promise<ServerActionResult> {
  try {
    const user = await getCurrentUser();
    const validatedData = AccountConfigFormDataSchema.parse(rawData);
    
    const now = getNowTimestamp(); // ‚úÖ Use utility function
    
    await accountConfigCollection.replaceOne(
      { userId: user.id },
      {
        ...validatedData,
        userId: user.id,
        createdAt: now,
        updatedAt: now
      },
      { upsert: true }
    );

    return { success: true };
  } catch (error) {
    // Error handling...
  }
}
```

### Optimized Slack Event Processing Pattern ‚úÖ UPDATED
```typescript
export async function handleMessageEvent(event: SlackMessageEvent): Promise<void> {
  try {
    // Validate event data
    const validatedEvent = SlackEventSchema.parse(event);
    
    // Check user has installed app and auto rephrase enabled
    const user = await slackUserCollection.findOne({
      slackId: validatedEvent.user,
      isActive: true
    });
    
    if (!user) return;
    
    // Check if auto-coaching is enabled for this channel
    if (!user.autoCoachingEnabledChannels.includes(channelId)) return;
    
    // Check bot is active in this channel
    const isChannelActive = await isChannelAccessible(
      validatedEvent.channel, 
      user.workspaceId
    );
    
    if (!isChannelActive) return; // Skip - bot not in channel
    
    // Get workspace-specific bot token
    const workspace = await workspaceCollection.findOne({ 
      _id: new ObjectId(user.workspaceId) 
    });
    
    if (!workspace?.botToken) return; // Skip - no bot token
    
    // Always fetch conversation history for better context
    const conversationHistory = await fetchConversationHistory(
      validatedEvent.channel, workspace.botToken, validatedEvent.ts, 15
    );
    
    // Single comprehensive AI analysis (replaces 4 separate AI calls)
    const analysis = await comprehensiveMessageAnalysis(
      validatedEvent.text, 
      conversationHistory
    );
    
    // Send ephemeral coaching feedback if needed
    if (analysis.needsCoaching && analysis.flags.length > 0 && analysis.improvedMessage) {
      await sendEphemeralMessage(/* interactive coaching feedback */);
    }
    
  } catch (error) {
    console.error('Message event processing error:', error);
  }
}
```

## Reports System Architecture ‚úÖ OPTIMIZED

### Incremental Data Approach
**Optimized for performance and cost efficiency:**

```typescript
// üéØ Only fetch current period data (90% fewer queries)
const currentWeekInstances = await analysisInstanceCollection.find({
    userId: user._id, // ‚úÖ Query with ObjectId directly
    createdAt: { $gte: weekAgo } // Only this week
}).toArray();

// üîÑ Compare with previous report (not raw messages)
const previousReport = await reportCollection.findOne({
    userId: user._id, // ‚úÖ Query with ObjectId directly
    period: 'weekly'
}, { sort: { createdAt: -1 } });
```

### Report Schema with Pre-calculated Metadata
**Location**: [src/types/index.ts](mdc:src/types/index.ts)

```typescript
export const ReportSchema = z.object({
    _id: z.string(),
    reportId: z.string(), // Long unguessable ID for security
    userId: z.string(),
    period: z.enum(['weekly', 'monthly']),
    
    // üìä Current period data only
    currentPeriod: z.object({
        totalMessages: z.number(),
        flaggedMessages: z.number(),
        flaggedMessageIds: z.array(z.string()), // For deep linking
        flagBreakdown: z.array(...), // With messageIds for examples
        partnerAnalysis: z.array(...), // Current period only
    }),
    
    // üìà Pre-calculated chart data (no recalculation needed)
    chartMetadata: z.object({
        flagTrends: z.array(...), // Current vs previous comparison
        scoreHistory: z.array(...), // Last 6 periods
        partnerTrends: z.array(...), // Relationship changes
    }),
});
```

### Reporting Data Rules ‚úÖ UPDATED (0‚Äì10 AI scoring, deterministic breakdowns)
- **Scoring**: `communicationScore` is AI-generated on a 0‚Äì10 scale (higher = better). Scripts pass:
  - Last two report scores and flag breakdowns for trend context
  - Severity weights per flag ID (e.g., rudeness > pushiness)
  - Coverage metadata and resolved partner names
- **Deterministic Sections** (computed locally from instances):
  - `currentPeriod.flagBreakdown` (counts/percentages; sorted)
  - `currentPeriod.partnerAnalysis` (messagesExchanged; sorted; only include partners with >0 instances)
- **AI-only Sections**: `communicationScore`, `scoreTrend`, `keyInsights`, and `focusExampleIndexes` (indexes referencing the enumerated instances). Do NOT store full message text in examples‚Äîpersist only IDs; summaries are computed at send time.
- **Normalization**: Before saving/DM, always ensure required fields exist with safe defaults (empty arrays instead of undefined; numbers set to 0 when missing).
- **Privacy**: Never store raw message content in reports; examples use `channelId`+`messageTs` deep links.
 
### Communication Score Persistence ‚úÖ NEW
- Persist the latest AI score per user per period to enable fast UI and comparisons.

```typescript
// Types (src/types/index.ts)
export const CommunicationScoreEntrySchema = z.object({
  score: z.number().min(0).max(10),
  reportId: z.string().optional(),
  updatedAt: z.coerce.date(),
});
export const CommunicationScoresSchema = z.object({
  weekly: CommunicationScoreEntrySchema.optional(),
  monthly: CommunicationScoreEntrySchema.optional(),
});

// SlackUser extension
export const SlackUserSchema = BaseUserSchema.extend({
  // ...existing fields
  communicationScores: CommunicationScoresSchema.optional(),
});

// Server Action (src/lib/server-actions.ts)
export async function saveCommunicationScore(
  userId: string,
  period: 'weekly' | 'monthly',
  score: number,
  meta: { reportId?: string }
) {
  const updateField = `communicationScores.${period}`;
  const update = {
    score: parseFloat(score.toFixed(1)),
    reportId: meta.reportId,
    updatedAt: new Date(),
  };
  return await slackUserCollection.findOneAndUpdate(
    { _id: new ObjectId(userId) },
    { $set: { [updateField]: update } },
    { returnDocument: 'after' }
  );
}
```

### Slack DM Examples Placement ‚úÖ UPDATED
- Place ‚ÄúTop flagged messages‚Äù section in DMs above action buttons with short snippets and an Open link built from `channelId` + `messageTs`.
- Do not render examples as extra buttons at the bottom.

### Workspace Token Usage ‚úÖ MANDATORY
- Always use the workspace-specific `botToken` from `workspaces` for Slack API calls. Never use global tokens.

### Report Generation Scripts
**Location**: [src/app/scripts/](mdc:src/app/scripts/)

```typescript
// Weekly reports: src/app/scripts/generate-weekly-reports.ts
// Monthly reports: src/app/scripts/generate-monthly-reports.ts
// Test reports: src/app/scripts/test-reports.ts

// Usage:
npm run reports:weekly:dev    // Generate weekly reports
npm run reports:monthly:dev   // Generate monthly reports  
npm run reports:all:dev       // Generate all reports
npm run reports:test:dev      // Test the system
```

### Performance Optimizations Achieved
- **Database Queries**: ~90% reduction (only current period)
- **AI Token Usage**: ~80% reduction (report comparisons vs raw messages)
- **Chart Generation**: Instant loading with pre-calculated metadata
- **Memory Usage**: ~95% reduction (small datasets vs full history)

### Report Utility Functions
**Location**: [src/lib/report-utils.ts](mdc:src/lib/report-utils.ts)

```typescript
// Optimized functions for incremental approach:
calculateCurrentFlagBreakdown(currentInstances) // Current period only
calculateChartMetadata(currentFlags, previousReport) // Compare reports
analyzeCommunicationPartners(currentInstances) // Current period analysis
```

### Report Pages and Components
- **Routes**: `/reports/weekly/[id]` and `/reports/monthly/[id]`
- **Components**: [src/components/reports/](mdc:src/components/reports/)
- **Security**: Long unguessable IDs (no authentication needed)
- **Charts**: Pre-calculated trends with current vs previous period

### Slack Integration
**Report delivery via DM with interactive buttons:**

```typescript
// Functions in src/lib/slack.ts
sendWeeklyReportDM(user, report, botToken)
sendMonthlyReportDM(user, report, botToken)

// Block Kit format with:
// - Communication score with trends
// - Top flag areas to focus on
// - Key insights and achievements
// - "View Full Report" button to webpage
```

### Script Termination Pattern
**All scripts properly terminate to prevent hanging:**

```typescript
// Pattern used in all report scripts
console.log('üéâ Report generation completed');

// Close database connection when running directly
if (require.main === module) {
    process.exit(0);
}

// Error handling with proper exit
generateReports().catch((error) => {
    console.error('‚ùå Report generation failed:', error);
    process.exit(1);
});
```

- **Batch operations**: Use `insertMany()` for multiple records
- **Selective fetching**: Only query current period data when needed
- **User validation**: Fail fast on ownership checks
- **Report efficiency**: Pre-calculate metadata to avoid repeated computations
