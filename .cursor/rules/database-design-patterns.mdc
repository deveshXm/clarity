---
description: Follow this rule while making changes in db schema.
globs: src/lib/**/*.ts,src/types/**/*.ts,src/app/api/**/*.ts
alwaysApply: false
---

# Database Design & Server Actions Rules

## Architecture (MongoDB Native Driver)

- Use the native MongoDB driver via [src/lib/db.ts](mdc:src/lib/db.ts); do not introduce ODM/ORM layers
- Database name must come from `process.env.MONGODB_DB_NAME`
- All database mutations and reads should live in Server Actions in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts)
- Validate all inputs with Zod schemas from [src/types/index.ts](mdc:src/types/index.ts)

## Collections Setup ✅ WORKSPACE-WIDE MODEL

```typescript
// Active collections in src/lib/db.ts
export const workspaceCollection = db.collection("workspaces");
export const slackUserCollection = db.collection("slackUsers");
export const botChannelsCollection = db.collection("botChannels");
export const analysisInstanceCollection = db.collection("analysisInstances");
export const reportCollection = db.collection("reports");
export const feedbackCollection = db.collection("feedback");
```

## Schema Definitions ✅ UPDATED

### Workspace Schema (Primary Entity)
```typescript
Workspace {
  _id: ObjectId,
  workspaceId: string,           // Slack team ID (T08HU2MKRK2)
  name: string,
  domain?: string,
  botToken: string,              // Workspace-specific bot token from OAuth
  isActive: boolean,
  adminSlackId?: string,         // Slack ID of workspace admin (installer)
  hasCompletedOnboarding: boolean, // Workspace onboarding status
  onboardingChannelId?: string,  // Channel for welcome announcement
  onboardingMessageTs?: string,  // Timestamp of welcome message
  subscription?: Subscription,   // WORKSPACE-LEVEL subscription
  stripeCustomerId?: string,
  stripeSubscriptionId?: string,
  createdAt: Date,
  updatedAt: Date
}
```

### SlackUser Schema (No Subscription)
```typescript
SlackUser {
  _id: ObjectId,
  slackId: string,                    // Slack user ID
  workspaceId: string,                // References workspace._id
  email?: string,                     // From Slack API via users:read.email
  name: string,
  displayName: string,
  image?: string,
  timezone?: string,
  isActive: boolean,
  isAdmin: boolean,                   // Admin role for workspace
  analysisFrequency: 'weekly' | 'monthly',
  autoCoachingEnabledChannels: string[], // Per-user channel preferences
  hasCompletedOnboarding: boolean,    // User's personal onboarding
  userToken?: string,                 // User's OAuth token for message updating
  communicationScores?: {             // Latest scores
    weekly?: { score: number, reportId?: string, updatedAt: Date },
    monthly?: { score: number, reportId?: string, updatedAt: Date }
  },
  createdAt: Date,
  updatedAt: Date
}
```

### Subscription Schema (On Workspace)
```typescript
Subscription {
  tier: 'FREE' | 'PRO',
  status: 'active' | 'cancelled' | 'past_due',
  currentPeriodStart: Date,
  currentPeriodEnd: Date,
  stripeCustomerId?: string,
  stripeSubscriptionId?: string,
  monthlyUsage: {
    autoCoaching: number,
    manualRephrase: number,
    personalFeedback: number
  },
  createdAt: Date,
  updatedAt: Date
}
```

## Key Patterns

### Workspace-Level vs User-Level Data
- **Workspace-Level**: `botToken`, `subscription`, `adminSlackId`, `stripeCustomerId`
- **User-Level**: `analysisFrequency`, `autoCoachingEnabledChannels`, `isAdmin`, `communicationScores`

### Admin Role Management
```typescript
// Set admin during installation (OAuth callback)
await workspaceCollection.updateOne(
  { workspaceId: teamId },
  { $set: { adminSlackId: authed_user.id } }
);

// Mark user as admin
await slackUserCollection.updateOne(
  { slackId: userId, workspaceId: workspaceObjectId.toString() },
  { $set: { isAdmin: true } }
);

// Transfer admin (only current admin can do this)
await workspaceCollection.updateOne(
  { _id: workspaceId, adminSlackId: currentAdminId },
  { $set: { adminSlackId: newAdminId } }
);
await slackUserCollection.updateOne(
  { slackId: currentAdminId },
  { $set: { isAdmin: false } }
);
await slackUserCollection.updateOne(
  { slackId: newAdminId },
  { $set: { isAdmin: true } }
);
```

### Subscription Validation Pattern
```typescript
// Check workspace subscription for access
const workspace = await workspaceCollection.findOne({ _id: new ObjectId(workspaceId) });
const subscription = workspace?.subscription;
const tier = subscription?.tier || 'FREE';
const limits = SUBSCRIPTION_TIERS[tier].monthlyLimits;

// User usage tracking still on user document
const user = await slackUserCollection.findOne({ slackId: userId });
const usage = user?.subscription?.monthlyUsage?.[feature] || 0;

if (usage >= limits[feature]) {
  // Limit reached - check if upgrade available
}
```

### Admin User Creation (OAuth Callback)
```typescript
// Admin user created during OAuth callback (not on first command)
// In src/app/api/auth/slack/callback/route.ts
const existingUser = await slackUserCollection.findOne({
  slackId: authed_user.id,
  workspaceId: workspaceObjectId.toString()
});

if (!existingUser) {
  await slackUserCollection.insertOne({
    _id: new ObjectId(),
    slackId: authed_user.id,
    workspaceId: workspaceObjectId.toString(),
    email: adminEmail,
    name: adminUserName,
    displayName: adminUserName,
    analysisFrequency: 'weekly',
    autoCoachingEnabledChannels: [],
    isAdmin: true,  // Admin flag set during install
    isActive: true,
    createdAt: new Date(),
    updatedAt: new Date()
  });
}
```

### Auto-Create Non-Admin Users on First Interaction
```typescript
// In commands handler - create non-admin user if they don't exist
if (!user) {
  const userInfo = await botClient.users.info({ user: payload.user_id });
  const newUserData = {
    _id: new ObjectId(),
    slackId: payload.user_id,
    workspaceId: workspace._id.toString(),
    email: userInfo.user?.profile?.email || null,
    name: userInfo.user?.real_name || 'Slack User',
    isActive: true,
    isAdmin: false,  // Non-admin users
    analysisFrequency: 'weekly',
    autoCoachingEnabledChannels: [],
    hasCompletedOnboarding: false,
    createdAt: new Date(),
    updatedAt: new Date()
  };
  await slackUserCollection.insertOne(newUserData);
}
```

## ObjectId Consistency Rules ✅ CRITICAL

- **Store ObjectId directly**: Use `user._id` not `user._id.toString()` when storing
- **Query with ObjectId**: Use `new ObjectId(idString)` for queries
- **Convert for Stripe**: Use `.toString()` when passing to Stripe metadata
- **Convert for URLs**: Use `String(workspace._id)` for URL parameters

```typescript
// ✅ CORRECT - Store ObjectId directly
await analysisInstanceCollection.insertOne({
  _id: new ObjectId(),
  userId: user._id,  // ObjectId directly
  workspaceId: user.workspaceId,
});

// ✅ CORRECT - Query with ObjectId
const workspace = await workspaceCollection.findOne({
  _id: new ObjectId(workspaceId)
});

// ✅ CORRECT - Convert for external use
const stripeClientRef = workspace._id.toString();
const urlParam = String(workspace._id);
```

## User Lifecycle Management

### Install/Reinstall Flow
- Create/update workspace with `botToken` and `adminSlackId`
- Create admin user in `slackUserCollection` with `isAdmin: true` during OAuth callback
- Set `isActive: true` on workspace and user
- Preserve monthly usage data (prevent gaming limits)
- Send welcome DM with "Complete Setup" button

### Uninstall Flow
- Set `isActive: false` on workspace and all users
- Remove all entries from `botChannelsCollection`
- Preserve all data for potential reinstall
- Track analytics event

```typescript
async function handleAppUninstall(teamId: string) {
  const workspace = await workspaceCollection.findOne({ workspaceId: teamId });
  
  // Deactivate users
  await slackUserCollection.updateMany(
    { workspaceId: workspace._id.toString() },
    { $set: { isActive: false, updatedAt: new Date() } }
  );
  
  // Clean up bot channels
  await botChannelsCollection.deleteMany({
    workspaceId: workspace._id.toString()
  });
  
  // Deactivate workspace
  await workspaceCollection.updateOne(
    { workspaceId: teamId },
    { $set: { isActive: false, updatedAt: new Date() } }
  );
}
```

## Slack Token Pattern ✅ MANDATORY

**Never use global bot tokens - always use workspace-specific tokens:**

```typescript
// ✅ CORRECT - Workspace-specific token
const workspace = await workspaceCollection.findOne({
  _id: new ObjectId(user.workspaceId)
});
const slack = new WebClient(workspace.botToken);

// ❌ WRONG - Global token causes auth errors
const slack = new WebClient(process.env.SLACK_BOT_TOKEN);
```

## Event-Driven Channel Management

```typescript
// Bot joined channel - add to database
async function handleBotJoinedChannel(event) {
  const workspace = await workspaceCollection.findOne({ workspaceId: event.team });
  await botChannelsCollection.insertOne({
    _id: new ObjectId(),
    workspaceId: workspace._id.toString(),
    channelId: event.channel,
    channelName: channelInfo.name,
    addedAt: new Date()
  });
}

// Bot left channel - remove from database
async function handleBotLeftChannel(event, teamId) {
  const workspace = await workspaceCollection.findOne({ workspaceId: teamId });
  await botChannelsCollection.deleteOne({
    channelId: event.channel,
    workspaceId: workspace._id.toString()
  });
}
```

## Index Recommendations

```javascript
// Workspace indexes
db.workspaces.createIndex({ workspaceId: 1 }, { unique: true });
db.workspaces.createIndex({ "subscription.stripeCustomerId": 1 });

// User indexes
db.slackUsers.createIndex({ slackId: 1, workspaceId: 1 }, { unique: true });
db.slackUsers.createIndex({ workspaceId: 1, isActive: 1 });

// Channel indexes
db.botChannels.createIndex({ channelId: 1, workspaceId: 1 }, { unique: true });

// Analysis indexes
db.analysisInstances.createIndex({ userId: 1, createdAt: -1 });
db.analysisInstances.createIndex({ workspaceId: 1, createdAt: -1 });
```
