---
description: Follow this rule while making changes in db schema.
globs: src/lib/**/*.ts,src/types/**/*.ts,src/app/api/**/*.ts
alwaysApply: false
---

# Database Design & Server Actions Rules

## Architecture (MongoDB Native Driver)

- Use the native MongoDB driver via [src/lib/db.ts](mdc:src/lib/db.ts); do not introduce ODM/ORM layers
- Database name must come from `process.env.MONGODB_DB_NAME`
- All database mutations and reads should live in Server Actions in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts)
- Validate all inputs with Zod schemas from [src/types/index.ts](mdc:src/types/index.ts)

## Collections Setup ✅ WORKSPACE-WIDE MODEL

```typescript
// Active collections in src/lib/db.ts
export const workspaceCollection = db.collection("workspaces");
export const slackUserCollection = db.collection("slackUsers");
export const botChannelsCollection = db.collection("botChannels");
export const analysisInstanceCollection = db.collection("analysisInstances");
export const feedbackCollection = db.collection("feedback");
```

## Schema Definitions ✅ UPDATED

### Workspace Schema (Primary Entity)
```typescript
Workspace {
  _id: ObjectId,
  workspaceId: string,           // Slack team ID (T08HU2MKRK2)
  name: string,
  domain?: string,
  botToken: string,              // Workspace-specific bot token from OAuth
  botUserId?: string,            // Bot's Slack user ID (for DM deep links)
  isActive: boolean,
  adminSlackId?: string,         // Slack ID of workspace admin (installer)
  hasCompletedOnboarding: boolean, // Workspace onboarding status
  onboardingChannelId?: string,  // Channel for welcome announcement
  onboardingMessageTs?: string,  // Timestamp of welcome message
  subscription?: Subscription,   // WORKSPACE-LEVEL subscription
  stripeCustomerId?: string,
  stripeSubscriptionId?: string,
  createdAt: Date,
  updatedAt: Date
}
```

### SlackUser Schema (No Subscription)
```typescript
SlackUser {
  _id: ObjectId,
  slackId: string,                    // Slack user ID
  workspaceId: string,                // References workspace._id
  email?: string,                     // From Slack API via users:read.email
  name: string,
  displayName: string,
  image?: string,
  isActive: boolean,
  isAdmin: boolean,                   // Admin role for workspace
  autoCoachingEnabledChannels: string[], // Per-user channel preferences
  coachingFlags: CoachingFlag[],      // User's coaching flags (seeded from DEFAULT_COACHING_FLAGS)
  userToken?: string,                 // User's OAuth token for message updating
  createdAt: Date,
  updatedAt: Date
}

// CoachingFlag schema (stored in user.coachingFlags array)
CoachingFlag {
  name: string,        // Max 50 chars
  description: string, // Max 200 chars
  enabled: boolean
}
```

### Subscription Schema (On Workspace)
```typescript
Subscription {
  tier: 'FREE' | 'PRO',
  status: 'active' | 'cancelled' | 'past_due',
  currentPeriodStart: Date,
  currentPeriodEnd: Date,
  stripeCustomerId?: string,
  stripeSubscriptionId?: string,
  monthlyUsage: {
    autoCoaching: number,
    manualRephrase: number
  },
  createdAt: Date,
  updatedAt: Date
}
```

### AnalysisInstance Schema (Coaching History)
```typescript
AnalysisInstance {
  _id: ObjectId,
  userId: string,           // MongoDB ObjectId as string
  workspaceId: string,
  channelId: string,
  messageTs: string,        // Slack timestamp for deep linking
  flagIds: number[],        // Array of flag indices (1-15)
  originalMessage: string,  // Original message text that was analyzed
  rephrasedMessage: string, // AI-generated improved message
  createdAt: Date
}
```

## Key Patterns

### Workspace-Level vs User-Level Data
- **Workspace-Level**: `botToken`, `botUserId`, `subscription`, `adminSlackId`, `stripeCustomerId`
- **User-Level**: `autoCoachingEnabledChannels`, `coachingFlags`, `isAdmin`, `userToken`

### Admin Role Management
```typescript
// Set admin during installation (OAuth callback)
await workspaceCollection.updateOne(
  { workspaceId: teamId },
  { $set: { adminSlackId: authed_user.id } }
);

// Mark user as admin
await slackUserCollection.updateOne(
  { slackId: userId, workspaceId: workspaceObjectId.toString() },
  { $set: { isAdmin: true } }
);

// Transfer admin (only current admin can do this)
await workspaceCollection.updateOne(
  { _id: workspaceId, adminSlackId: currentAdminId },
  { $set: { adminSlackId: newAdminId } }
);
await slackUserCollection.updateOne(
  { slackId: currentAdminId },
  { $set: { isAdmin: false } }
);
await slackUserCollection.updateOne(
  { slackId: newAdminId },
  { $set: { isAdmin: true } }
);
```

### Subscription Validation Pattern
```typescript
// Check workspace subscription for access
const workspace = await workspaceCollection.findOne({ _id: new ObjectId(workspaceId) });
const subscription = workspace?.subscription;
const tier = subscription?.tier || 'FREE';
const limits = SUBSCRIPTION_TIERS[tier].monthlyLimits;

// User usage tracking still on user document
const user = await slackUserCollection.findOne({ slackId: userId });
const usage = user?.subscription?.monthlyUsage?.[feature] || 0;

if (usage >= limits[feature]) {
  // Limit reached - check if upgrade available
}
```

### Admin User Creation (OAuth Callback)
```typescript
// Admin user created during OAuth callback (not on first command)
// In src/app/api/auth/slack/callback/route.ts
const existingUser = await slackUserCollection.findOne({
  slackId: authed_user.id,
  workspaceId: workspaceObjectId.toString()
});

if (!existingUser) {
  await slackUserCollection.insertOne({
    _id: new ObjectId(),
    slackId: authed_user.id,
    workspaceId: workspaceObjectId.toString(),
    email: adminEmail,
    name: adminUserName,
    displayName: adminUserName,
    autoCoachingEnabledChannels: [],
    coachingFlags: [...DEFAULT_COACHING_FLAGS],
    isAdmin: true,  // Admin flag set during install
    isActive: true,
    createdAt: new Date(),
    updatedAt: new Date()
  });
}
```

### Auto-Create Non-Admin Users on First Interaction
```typescript
// In commands handler - create non-admin user if they don't exist
if (!user) {
  const userInfo = await botClient.users.info({ user: payload.user_id });
  const newUserData = {
    _id: new ObjectId(),
    slackId: payload.user_id,
    workspaceId: workspace._id.toString(),
    email: userInfo.user?.profile?.email || null,
    name: userInfo.user?.real_name || 'Slack User',
    isActive: true,
    isAdmin: false,  // Non-admin users
    autoCoachingEnabledChannels: [],
    coachingFlags: [...DEFAULT_COACHING_FLAGS],
    createdAt: new Date(),
    updatedAt: new Date()
  };
  await slackUserCollection.insertOne(newUserData);
}
```

### Save Analysis Instance (Auto-Coaching & Manual Rephrase)
```typescript
// Save analysis instance when coaching suggestion is generated
const instanceData = {
  _id: new ObjectId(),
  userId: user._id,
  workspaceId: String(workspace._id),
  channelId: channelId,
  messageTs: event.ts,  // or Date.now().toString() for manual rephrase
  flagIds: analysis.flags.map(f => f.flagIndex),
  originalMessage: messageText,
  rephrasedMessage: analysis.suggestedRephrase,
  createdAt: new Date(),
};
await analysisInstanceCollection.insertOne(instanceData);
```

## ObjectId Consistency Rules ✅ CRITICAL

- **Store ObjectId directly**: Use `user._id` not `user._id.toString()` when storing
- **Query with ObjectId**: Use `new ObjectId(idString)` for queries
- **Convert for Stripe**: Use `.toString()` when passing to Stripe metadata
- **Convert for URLs**: Use `String(workspace._id)` for URL parameters

```typescript
// ✅ CORRECT - Store ObjectId directly
await analysisInstanceCollection.insertOne({
  _id: new ObjectId(),
  userId: user._id,  // ObjectId directly
  workspaceId: user.workspaceId,
});

// ✅ CORRECT - Query with ObjectId
const workspace = await workspaceCollection.findOne({
  _id: new ObjectId(workspaceId)
});

// ✅ CORRECT - Convert for external use
const stripeClientRef = workspace._id.toString();
const urlParam = String(workspace._id);
```

## User Lifecycle Management

### Install/Reinstall Flow
- Create/update workspace with `botToken`, `botUserId`, and `adminSlackId`
- Create admin user in `slackUserCollection` with `isAdmin: true` during OAuth callback
- Set `isActive: true` on workspace and user
- Preserve monthly usage data (prevent gaming limits)
- Send welcome DM with "Complete Setup" button
- Redirect to docs with deep link params (`openSlack`, `botId`)

### Uninstall Flow
- Set `isActive: false` on workspace and all users
- Remove all entries from `botChannelsCollection`
- Preserve all data for potential reinstall
- Track analytics event

```typescript
async function handleAppUninstall(teamId: string) {
  const workspace = await workspaceCollection.findOne({ workspaceId: teamId });
  
  // Deactivate users
  await slackUserCollection.updateMany(
    { workspaceId: workspace._id.toString() },
    { $set: { isActive: false, updatedAt: new Date() } }
  );
  
  // Clean up bot channels
  await botChannelsCollection.deleteMany({
    workspaceId: workspace._id.toString()
  });
  
  // Deactivate workspace
  await workspaceCollection.updateOne(
    { workspaceId: teamId },
    { $set: { isActive: false, updatedAt: new Date() } }
  );
}
```

## Slack Token Pattern ✅ MANDATORY

**Never use global bot tokens - always use workspace-specific tokens:**

```typescript
// ✅ CORRECT - Workspace-specific token
const workspace = await workspaceCollection.findOne({
  _id: new ObjectId(user.workspaceId)
});
const slack = new WebClient(workspace.botToken);

// ❌ WRONG - Global token causes auth errors
const slack = new WebClient(process.env.SLACK_BOT_TOKEN);
```

## Event-Driven Channel Management

```typescript
// Bot joined channel - add to database
async function handleBotJoinedChannel(event) {
  const workspace = await workspaceCollection.findOne({ workspaceId: event.team });
  await botChannelsCollection.insertOne({
    _id: new ObjectId(),
    workspaceId: workspace._id.toString(),
    channelId: event.channel,
    channelName: channelInfo.name,
    context: [],  // Empty context array, populated as messages arrive
    addedAt: new Date()
  });
}

// Bot left channel - remove from database
async function handleBotLeftChannel(event, teamId) {
  const workspace = await workspaceCollection.findOne({ workspaceId: teamId });
  await botChannelsCollection.deleteOne({
    channelId: event.channel,
    workspaceId: workspace._id.toString()
  });
}
```

## Channel Message Context (FIFO Queue)

Each bot channel stores the last 20 messages for AI context. **Must run unconditionally** — before any subscription, onboarding, or user-level checks.

```typescript
// Store message in context (atomic push + slice)
const channelDoc = await botChannelsCollection.findOneAndUpdate(
  { channelId, workspaceId },
  { $push: { context: { $each: [{ text, user, ts }], $slice: -20 } } },
  { returnDocument: 'before' }  // Returns pre-push state for AI context
);
const channelContext = channelDoc?.context || [];
```

### Context Document Shape
```typescript
// Stored in botChannelsCollection.context array
{ text: string, user: string, ts: string }  // ContextMessage type
```

### ⚠️ CRITICAL: Ordering in Message Handler
Context push MUST happen before subscription/onboarding gates:
1. Find workspace
2. Check bot is in channel
3. **Push to context** ← here, unconditionally
4. Check onboarding
5. Check subscription access
6. Check user opt-in
7. AI analysis with context

## Index Recommendations

```javascript
// Workspace indexes
db.workspaces.createIndex({ workspaceId: 1 }, { unique: true });
db.workspaces.createIndex({ "subscription.stripeCustomerId": 1 });

// User indexes
db.slackUsers.createIndex({ slackId: 1, workspaceId: 1 }, { unique: true });
db.slackUsers.createIndex({ workspaceId: 1, isActive: 1 });

// Channel indexes
db.botChannels.createIndex({ channelId: 1, workspaceId: 1 }, { unique: true });

// Analysis indexes
db.analysisInstances.createIndex({ userId: 1, createdAt: -1 });
db.analysisInstances.createIndex({ workspaceId: 1, createdAt: -1 });
```
