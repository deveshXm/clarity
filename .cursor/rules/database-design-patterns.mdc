---
description: Follow this rule while making changes in db schema.
globs: src/lib/**/*.ts,src/types/**/*.ts,src/app/api/**/*.ts
---

# Database Design & Server Actions Rules

## Operational Guidelines

- Do not run builds unless explicitly asked
  - Avoid `npm run build` during iterative edits; rely on type checks/lint where needed.

- GSAP is available (FYI)
  - The project has `gsap` installed for UI work. It is irrelevant for database code; do not add animation deps.

## Architecture (MongoDB Native Driver)

- Use the native MongoDB driver via the shared client at [src/lib/db.ts](mdc:src/lib/db.ts); do not introduce ODM/ORM layers.
- Database name must come from `process.env.MONGODB_DB_NAME`.
- All database mutations and reads should live in Server Actions in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts).
- Validate all inputs with Zod schemas from [src/types/index.ts](mdc:src/types/index.ts) before performing DB operations.

## Patterns

- Collections: keep workspace-scoped data keyed by workspace identifiers; store Slack workspace `botToken` on the workspace record.
- Avoid over-normalization; prefer simple documents with clear ownership and indexing.
- Use explicit TypeScript types inferred from Zod schemas; never use `any`.
- When adding fields, prefer additive, backward-compatible changes; write guards for optional legacy fields.
- **Email Field**: User email is nullable in schema, defaults to `null` for new users, collected during onboarding

## User Lifecycle Management ✅ ENHANCED

- **Never delete users or workspaces** - use `isActive: boolean` field for deactivation
- **Install/Reinstall Flow**: Set `isActive: true` and overwrite all values except usage data
- **Uninstall Flow**: Set `isActive: false`, preserve all user data, and clean up botChannels collection
- **Prevents Usage Abuse**: Users can't reset limits by uninstalling/reinstalling

### Reinstallation Behavior ✅ UPDATED
- **Fresh Start**: All preferences, settings, and onboarding status reset to defaults
- **Usage Protection**: Monthly usage counters and subscription data preserved
- **Complete Overwrite**: Profile, settings, channel preferences, onboarding status reset
- **OAuth Callback Pattern**:
  ```typescript
  const existingUser = await slackUserCollection.findOne({ slackId, workspaceId });
  if (existingUser) {
    // Preserve usage but overwrite everything else
    const preservedUsage = existingUser.subscription?.monthlyUsage;
    const updatedSubscription = {
      ...defaultSubscription,
      monthlyUsage: preservedUsage, // Keep usage data
      tier: existingUser.subscription?.tier || 'FREE', // Keep subscription tier
      stripeCustomerId: existingUser.subscription?.stripeCustomerId, // Keep Stripe data
    };
    
    await slackUserCollection.updateOne(
      { slackId, workspaceId },
      { 
        $set: { 
          // Overwrite ALL fields except usage
          isActive: true,
          email: null, // Reset email - user must provide during onboarding
          analysisFrequency: 'weekly', // Reset to default
          autoCoachingDisabledChannels: [], // Reset channel preferences  
          hasCompletedOnboarding: false, // Reset onboarding
          subscription: updatedSubscription, // Preserve usage, reset other settings
          // ... all other fields reset to defaults
        }
      }
    );
  }
  ```

### Uninstallation Cleanup ✅ ENHANCED
- **App Uninstall Handler**: Listen for `app_uninstalled` and `tokens_revoked` events in [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts)
- **Complete Cleanup**: `handleAppUninstall(teamId)` function now:
  - Deactivates all workspace users (`isActive: false`)
  - Deactivates workspace (`isActive: false`) 
  - **NEW**: Removes all entries from `botChannelsCollection` for the workspace
  - **NEW**: Tracks uninstallation analytics with user/channel counts
- **Channel Cleanup**: `botChannelsCollection.deleteMany({ workspaceId })` removes stale channel references
- **Analytics Tracking**: `API_SLACK_APP_UNINSTALLED` event tracks deactivation metrics
- **Manifest Events Required**: Add both `app_uninstalled` and `tokens_revoked` to bot_events in manifest files

## Slack Tokens & Access

- Never use a global Slack bot token. Always look up the workspace-specific token from the database.
- Keep channel access checks in server actions, not client components.

## Testing & Migrations

- Keep migrations minimal and reversible. For complex changes, write idempotent migration steps in a dedicated script (ask before adding files).
- Do not create new files without explicit approval in this project; co-locate light migration helpers in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) when necessary.
---
description: Follow this rule while making changes in db schema.
alwaysApply: false
---
# Database Design Patterns

## Collection Separation Strategy

### Generic Boilerplate Collections
```typescript
// Core collections for boilerplate
User {
  _id: string,
  id: string,
  email: string,
  name: string,
  image?: string,
  emailVerified: boolean,
  hasCompletedOnboarding?: boolean,
  createdAt: Date,
  updatedAt: Date
}

AccountConfig {
  _id: string,
  userId: string,
  companyName: string,
  websiteUrl?: string,
  createdAt: Date,
  updatedAt: Date
}
```

## Database Configuration

### Collections Setup
**Location**: [src/lib/db.ts](mdc:src/lib/db.ts)

```typescript
// Core collections
export const userCollection = db.collection("user")
export const accountConfigCollection = db.collection("accountConfig")

// Slack-specific collections
export const workspaceCollection = db.collection("workspaces")
export const slackUserCollection = db.collection("slackUsers")
export const botChannelsCollection = db.collection("botChannels")
export const invitationCollection = db.collection("invitations")
export const analysisInstanceCollection = db.collection("analysisInstances")
```

### Naming Convention
- **Database**: Use `process.env.MONGODB_DB_NAME` (configurable)
- **Collections**: camelCase names
- **Application**: Generic names like "Your App"

### Slack-Specific Collections

```typescript
// Workspace with bot token for API calls
Workspace {
  _id: ObjectId,
  workspaceId: string,     // Slack team ID (T08HU2MKRK2)
  name: string,
  domain?: string,
  botToken: string,        // Workspace-specific bot token from OAuth
  createdAt: Date,
  updatedAt: Date
}

// Bot channel tracking for access control
BotChannel {
  _id: ObjectId,
  workspaceId: string,     // User's workspace ObjectId (relationship key)
  channelId: string,       // Slack channel ID
  channelName: string,     // Display name
  addedAt: Date
}

// Slack user linked to workspace
SlackUser {
  _id: ObjectId,
  slackId: string,         // Slack user ID
  workspaceId: string,     // References workspace ObjectId
  analysisFrequency: 'weekly' | 'monthly',
  autoCoachingDisabledChannels: string[],  // Channel IDs where auto-coaching is disabled (default: empty array)
  hasCompletedOnboarding: boolean,
  subscription: SubscriptionSchema, // Includes usage tracking and tier info
  // ... other user fields
}
```

## Slack Event Handling & Auto Coaching Patterns

### 1. Event Subscription Requirements ✅ CRITICAL
**Bot only receives events from channels where it's a member:**

```typescript
// Slack sends message.channels events ONLY from:
// 1. Channels where bot is explicitly added
// 2. Channels bot joined via conversations.join API
// 3. NOT from all public channels (privacy protection)

// Manifest.json event subscriptions required:
"bot_events": [
  "message.channels",    // Public channel messages (REQUIRED for auto coaching)
  "message.groups",      // Private channel messages  
  "app_mention"          // @bot mentions
]
```

### 2. Channel Access Control Pattern ✅ IMPLEMENTED
**Double-layer security for message processing:**

```typescript
// Layer 1: Slack's membership filter (automatic)
// Layer 2: Our database verification (kept in sync via events)
const isChannelActive = await botChannelsCollection.findOne({
  channelId: slackChannelId,
  workspaceId: userWorkspaceObjectId  // User's workspace reference
})

if (!isChannelActive) {
  console.log('⏭️ Bot not active in this channel, skipping analysis');
  return; // Skip processing - bot not authorized
}
```

### 3. Optimized Auto Coaching Flow ✅ UPDATED
**Single AI call comprehensive analysis pipeline:**

```typescript
// Step 1: Receive message event (only from member channels)
if (event.type === 'message' && (event.channel_type === 'channel' || event.channel_type === 'group')) {
  
  // Step 2: Validate user has app installed and check per-channel auto-coaching
  const user = await slackUserCollection.findOne({ 
    slackId: event.user, 
    isActive: true 
  });
  if (!user) return;
  
  // Step 2.5: Check if auto-coaching is disabled for this specific channel
  if (user.autoCoachingDisabledChannels.includes(event.channel)) return;
  
  // Step 3: Check bot is active in this specific channel
  const isChannelActive = await isChannelAccessible(event.channel, user.workspaceId);
  if (!isChannelActive) return; // Skip - not authorized channel
  
  // Step 4: Get workspace-specific bot token
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  if (!workspace?.botToken) return; // Skip - missing token
  
  // Step 5: Always fetch conversation history for better context
  const conversationHistory = await fetchConversationHistory(event.channel, workspace.botToken, event.ts, 15);
  
  // Step 6: Single comprehensive AI analysis (replaces 4 separate AI calls)
  const analysis = await comprehensiveMessageAnalysis(event.text, conversationHistory);
  
  // Step 7: Send ephemeral coaching feedback if needed (private to user)
  if (analysis.needsCoaching && analysis.flags.length > 0 && analysis.improvedMessage) {
    // Send interactive Block Kit message with improved version
  }
}
```

### 4. Command Authorization Pattern ✅ SIMPLIFIED
**Simple database presence check for command access:**

```typescript
// Check if user exists in database (authorized via website)
const appUser = await slackUserCollection.findOne({
  slackId: userId,
  isActive: true
});

if (!appUser) {
  // User not in database - show authorization message
  const { getSlackOAuthUrl } = await import('@/lib/slack');
  const authUrl = getSlackOAuthUrl();
  
  return NextResponse.json({
    text: '🤗 Welcome to Clarity! Before I help you write effortlessly, I need you to authorize. Simply click the button below.',
    response_type: 'ephemeral',
    blocks: [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: '🤗 *Welcome to Clarity!* Before I help you write effortlessly, I need you to authorize. Simply click the button below.'
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Authorize with Website',
              emoji: true
            },
            url: authUrl,
            action_id: 'authorize_website'
          }
        ]
      }
    ]
  });
}
```

### 5. Slack Commands Implementation ✅ CURRENT
**Available commands in [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts):**

```typescript
// Command routing in switch statement - ALL commands use clarity- prefix
switch (command) {
  case '/clarity-help':
    response = await handleClarityHelp();
    break;
  case '/clarity-personal-feedback':  // ✅ Updated with clarity- prefix
    response = await handlePersonalFeedback(userId, channelId);
    break;
  case '/clarity-rephrase':  // ✅ Updated with clarity- prefix
    response = await handleRephrase(text, userId, channelId);
    break;
  case '/clarity-settings':  // ✅ Updated with clarity- prefix
    response = await handleSettings(text, userId, appUser as unknown as SlackUser, triggerId!);
    break;
  case '/clarity-status':  // ✅ NEW: Channel status checking
    response = await handleClarityStatus(userId, channelId, appUser as unknown as SlackUser);
    break;
}
```

**Help Command Pattern:**
```typescript
// /clarity-help - 2x2 grid layout with help button
async function handleClarityHelp() {
  return {
    text: 'Clarity Help',
    response_type: 'ephemeral',
    blocks: [
      {
        type: 'header',
        text: { type: 'plain_text', text: 'Clarity Help' }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: '_Show all available Clarity commands and features_\n\n`/clarity-help`'
          },
          {
            type: 'mrkdwn', 
            text: '_Rephrase your original text for clarity or variation_\n\n`/rephrase your_original_text`'
          }
        ]
      },
      // ... more command rows
      {
        type: 'section',
        text: { type: 'mrkdwn', text: '*Need more help?*' },
        accessory: {
          type: 'button',
          text: { type: 'plain_text', text: 'View Guide', emoji: true },
          style: 'primary',
          url: `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/app/help`
        }
      }
    ]
  };
}
```

**Status Command Pattern ✅ NEW:**
```typescript
// /clarity-status - Channel status checking with visual indicators
async function handleClarityStatus(userId: string, channelId: string, user: SlackUser) {
  // 1. Channel type detection using ID prefixes
  if (!channelId.startsWith('C') && !channelId.startsWith('G')) {
    return {
      text: 'Please use this command in a channel to check Clarity\'s status.',
      response_type: 'ephemeral'
    };
  }

  // 2. Check bot installation using existing isChannelAccessible function
  const isChannelActive = await isChannelAccessible(channelId, user.workspaceId);
  
  if (!isChannelActive) {
    return {
      text: '🔴 Clarity is not installed in this channel.',
      response_type: 'ephemeral'
    };
  }

  // 3. Check per-channel auto-coaching settings
  const isAutoCoachingDisabled = user.autoCoachingDisabledChannels.includes(channelId);
  
  if (isAutoCoachingDisabled) {
    return {
      text: '🟡 Clarity is installed but auto coaching is disabled in this channel.',
      response_type: 'ephemeral'
    };
  }

  // 4. Fully active status
  return {
    text: '🟢 Clarity is installed and monitoring this channel for auto coaching.',
    response_type: 'ephemeral'
  };
}
```

**Status Detection Logic:**
- **Channel Types**: `C` (public), `G` (private), `D` (DM) - only work in channels
- **Bot Installation**: Uses `isChannelAccessible()` to check `botChannelsCollection`
- **Auto-Coaching Status**: Checks `user.autoCoachingDisabledChannels` array
- **Visual Indicators**: 🔴 (not installed), 🟡 (disabled), 🟢 (active)

## Query Patterns

### 1. User Validation
**Always validate before data access:**

```typescript
// Standard pattern in server actions
const user = await userCollection.findOne({
  _id: new ObjectId(userId)
})

if (!user) {
  return { success: false, error: 'User not found' }
}
```

### 2. Account Config Fetching
**After user validation:**

```typescript
const accountConfig = await accountConfigCollection.findOne({ 
  userId: userId 
})

// Always serialize MongoDB _id to string
const serializedConfig = accountConfig ? {
  ...accountConfig,
  _id: accountConfig._id.toString()
} : null
```

### 3. Workspace Token Lookup Pattern ✅ CRITICAL
**For Slack API calls with workspace-specific tokens:**

```typescript
// Get workspace by Slack team ID
const workspace = await workspaceCollection.findOne({ 
  workspaceId: teamId  // Slack team ID like T08HU2MKRK2
})

// Get workspace by user's workspace ObjectId
const workspace = await workspaceCollection.findOne({ 
  _id: new ObjectId(userWorkspaceId) 
})

if (!workspace || !workspace.botToken) {
  return { error: 'Workspace not found or missing bot token' }
}

// Use workspace-specific token for API calls
const workspaceSlack = new WebClient(workspace.botToken)
```

### 4. Channel Access Control Pattern
**Check if bot is active in channel:**

```typescript
const isChannelActive = await botChannelsCollection.findOne({
  channelId: slackChannelId,
  workspaceId: userWorkspaceObjectId  // User's workspace reference
})

if (!isChannelActive) {
  // Skip processing - bot not active in this channel
  return
}
```

### 5. Bot Channel Management Pattern ✅ EVENT-DRIVEN ARCHITECTURE
**Event-driven channel membership tracking:**

```typescript
// Onboarding: Only join channels (events handle database)
for (const channel of selectedChannels) {
  const joinSuccess = await joinChannel(channel.id, workspace.botToken);
  
  if (joinSuccess) {
    // member_joined_channel event will update botChannelsCollection automatically
    console.log(`✅ Bot joined channel: ${channel.name}`);
  }
}

// Event handlers in /api/slack/events/route.ts
async function handleBotJoinedChannel(event) {
  // Verify it's our bot joining
  const botUserId = await slack.auth.test().user_id;
  if (event.user !== botUserId) return;
  
  // Add to database
  await botChannelsCollection.insertOne({
    _id: new ObjectId(),
    workspaceId: workspace._id.toString(),
    channelId: event.channel,
    channelName: channelInfo.name,
    addedAt: new Date()
  });
}

async function handleBotLeftChannel(event) {
  // Remove from database when bot leaves
  await botChannelsCollection.deleteOne({
    channelId: event.channel,
    workspaceId: workspace._id.toString()
  });
}
```

**Key Benefits:**
- **Single Source of Truth**: Slack events drive ALL channel membership changes
- **Manual Addition Support**: Users can add bot to channels after onboarding
- **Automatic Sync**: Database always reflects actual bot membership
- **No Race Conditions**: Events ensure consistency between Slack and database

## Type System Integration

### Schema Location
**All schemas in**: [src/types/index.ts](mdc:src/types/index.ts)

### Pattern: Schema → Type Inference
```typescript
// 1. Define Zod schema first
export const AccountConfigSchema = z.object({
  _id: z.string(),
  userId: z.string(),
  companyName: z.string().min(1),
  websiteUrl: z.string().url().optional(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
})

// 2. Infer TypeScript type
export type AccountConfig = z.infer<typeof AccountConfigSchema>

// 3. Create input schema (omit auto-generated fields)
export const CreateAccountConfigSchema = AccountConfigSchema.omit({ 
  _id: true, 
  createdAt: true, 
  updatedAt: true 
})

export type CreateAccountConfigInput = z.infer<typeof CreateAccountConfigSchema>
```

### Slack Event Validation
```typescript
// Validate incoming Slack events
export const SlackEventSchema = z.object({
  type: z.literal('message'),
  user: z.string(),
  text: z.string(),
  channel: z.string(),
  ts: z.string(),
  channel_type: z.enum(['channel', 'group'])
});
```

## Data Consistency Patterns

### 1. Timestamp Handling
**Use millisecond epoch timestamps for all date fields:**

```typescript
// Import the utility function
import { getNowTimestamp } from '@/lib/utils';

// Use for all date fields
const now = getNowTimestamp(); // Returns millisecond epoch timestamp

// Example usage in database operations
await accountConfigCollection.insertOne({
  ...data,
  createdAt: now,
  updatedAt: now
});
```

### 2. Status Management
**Consistent status patterns:**

```typescript
type Status = "pending" | "completed" | "failed"

// Example for future task implementations
task.status = "pending" → "completed"
```

## Security Patterns

### 1. User Isolation
**Always filter by userId:**

```typescript
// Account config access
{ userId: user.id }

// Always verify ownership before operations
const config = await accountConfigCollection.findOne({ 
  _id: new ObjectId(configId),
  userId: user.id 
})
```

### 2. Data Serialization
**Always convert ObjectId to string:**

```typescript
const serializedConfig: AccountConfig = {
  _id: config._id.toString(), // ✅ Convert ObjectId
  userId: config.userId,
  companyName: config.companyName,
  websiteUrl: config.websiteUrl,
  createdAt: config.createdAt,
  updatedAt: config.updatedAt
}
```

### 5. Slack Privacy Protection ✅ SIMPLIFIED
**Multi-layer privacy safeguards:**

```typescript
// Layer 1: Slack only sends events from channels where bot is member
// Layer 2: Our database tracks authorized channels only
// Layer 3: User must exist in database (authorized via website)
// Layer 4: Ephemeral messages are private (only sender sees feedback)

// Privacy by design:
// - No message storage (only analysis results)
// - User controls which channels to enable
// - Coaching feedback is private and ephemeral
// - Simple authorization: user in database = authorized
```

## AI Architecture Optimizations ✅ NEW

### 1. Single AI Call Auto-Coaching
**Optimized from 4 AI calls to 1 comprehensive call:**

```typescript
// OLD APPROACH (4 separate AI calls):
// 1. quickCheckNeedsCoaching(message) → AI Call #1
// 2. analyzeMessageForFlags(message, context) → AI Call #2  
// 3. generateImprovedMessage(message, flagType) → AI Call #3
// 4. identifyMessageTarget(message, context) → AI Call #4

// NEW APPROACH (1 comprehensive AI call):
const analysis = await comprehensiveMessageAnalysis(message, conversationHistory);
// Returns: { needsCoaching, flags, target, improvedMessage, reasoning }
```

### 2. GPT-5 Prompting Best Practices
**Tone adaptation and natural language generation:**

```typescript
// Prompt guidelines for improved messages:
// - Match the user's tone, register, and formality
// - Keep approximately the same length unless brevity helps
// - Preserve Slack specifics: @mentions, <#channel> references, links, code
// - Avoid AI-ish phrasing, hedging, or generic filler
// - Sound human and natural - like the same person wrote it, just better
```

### 3. Performance Gains
- **Speed**: ~75% faster response times (1 AI call vs 4)
- **Cost**: ~75% reduction in API costs
- **Accuracy**: Better analysis with full context always available
- **Reliability**: Fewer API calls = fewer potential failure points

### 4. Azure OpenAI Configuration
**Optimized for speed with low reasoning effort:**

```typescript
// src/lib/ai.ts configuration
const response = await openaiClient.chat.completions.create({
  messages,
  model: modelName,
  reasoning_effort: 'low', // Optimized for speed
  response_format: { type: 'json_object' },
});
```

## Performance Optimizations

### 1. Document Size Limits
- **User documents**: Minimal, essential auth data only
- **Account config documents**: Simple configuration data
- **Query efficiency**: Direct access without complex joins

### 2. Index Recommendations (Future)
```javascript
// Recommended indexes for production:
db.user.createIndex({ "email": 1 })
db.user.createIndex({ "id": 1 })
db.accountConfig.createIndex({ "userId": 1 })

// Slack-specific indexes
db.slackUsers.createIndex({ "slackId": 1 })
db.workspaces.createIndex({ "workspaceId": 1 })
db.botChannels.createIndex({ "channelId": 1, "workspaceId": 1 })
```

### 3. Query Optimization
- **Batch operations**: Use `insertMany()` for multiple records
- **Selective fetching**: Only query data when needed
- **User validation**: Fail fast on ownership checks

## Migration Strategy

### What Was Removed (Boilerplate Cleanup)
- ❌ Creative-related collections and schemas
- ❌ Complex account configuration fields
- ❌ AI-specific data structures
- ❌ Image and media collections

### What Was Added
- ✅ Simplified user and account config collections
- ✅ Generic account configuration schema
- ✅ Basic onboarding flow data
- ✅ Clean, minimal database structure
- ✅ Slack-specific collections for bot management
- ✅ Workspace token storage and channel access control

### Data Migration Notes
**For boilerplate**: No migration needed - clean slate
**For production data**: Would need custom migration scripts based on specific requirements

## Utility Functions

### Timestamp Utility
**Location**: [src/lib/utils.ts](mdc:src/lib/utils.ts)

```typescript
// Use this function for all timestamp fields
export const getNowTimestamp = (): number => {
  return Date.now(); // Returns millisecond epoch timestamp
};
```

**Usage in database operations:**
```typescript
import { getNowTimestamp } from '@/lib/utils';

// Always use this for timestamps
const now = getNowTimestamp();

await collection.insertOne({
  ...data,
  createdAt: now,
  updatedAt: now
});
```

## Example Implementation

### Server Action Pattern
```typescript
export async function upsertAccountConfig(rawData: AccountConfigFormData): Promise<ServerActionResult> {
  try {
    const user = await getCurrentUser();
    const validatedData = AccountConfigFormDataSchema.parse(rawData);
    
    const now = getNowTimestamp(); // ✅ Use utility function
    
    await accountConfigCollection.replaceOne(
      { userId: user.id },
      {
        ...validatedData,
        userId: user.id,
        createdAt: now,
        updatedAt: now
      },
      { upsert: true }
    );

    return { success: true };
  } catch (error) {
    // Error handling...
  }
}
```

### Optimized Slack Event Processing Pattern ✅ UPDATED
```typescript
export async function handleMessageEvent(event: SlackMessageEvent): Promise<void> {
  try {
    // Validate event data
    const validatedEvent = SlackEventSchema.parse(event);
    
    // Check user has installed app and auto rephrase enabled
    const user = await slackUserCollection.findOne({
      slackId: validatedEvent.user,
      isActive: true
    });
    
    if (!user) return;
    
    // Check if auto-coaching is disabled for this channel
    if (user.autoCoachingDisabledChannels.includes(channelId)) return;
    
    // Check bot is active in this channel
    const isChannelActive = await isChannelAccessible(
      validatedEvent.channel, 
      user.workspaceId
    );
    
    if (!isChannelActive) return; // Skip - bot not in channel
    
    // Get workspace-specific bot token
    const workspace = await workspaceCollection.findOne({ 
      _id: new ObjectId(user.workspaceId) 
    });
    
    if (!workspace?.botToken) return; // Skip - no bot token
    
    // Always fetch conversation history for better context
    const conversationHistory = await fetchConversationHistory(
      validatedEvent.channel, workspace.botToken, validatedEvent.ts, 15
    );
    
    // Single comprehensive AI analysis (replaces 4 separate AI calls)
    const analysis = await comprehensiveMessageAnalysis(
      validatedEvent.text, 
      conversationHistory
    );
    
    // Send ephemeral coaching feedback if needed
    if (analysis.needsCoaching && analysis.flags.length > 0 && analysis.improvedMessage) {
      await sendEphemeralMessage(/* interactive coaching feedback */);
    }
    
  } catch (error) {
    console.error('Message event processing error:', error);
  }
}
```

- **Batch operations**: Use `insertMany()` for multiple images
- **Selective fetching**: Only query images when needed
- **User validation**: Fail fast on ownership checks
