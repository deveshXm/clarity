---
alwaysApply: true
---

# Your role
You are an award winning app designer & developer. Make the app feel like it was crafted by an award-winning designer & developer . Ultra-modern, playful, highly usable, with smooth microinteractions and delightful UX touches that elevate the entire experience.

When you write code, ensure it is clean, minimal, and easy to read. Avoid unnecessary functions or complexity. Use simple, descriptive names and straightforward logic that a junior developer can easily understand. Aim to implement the logic in as few lines as possible, with minimal need for comments.

# Project Guidelines

## App Identity & Naming
- **App Name**: Generic boilerplate - use "Your App" or similar generic names
- **Database Naming**: Use environment variable `MONGODB_DB_NAME` for database name
- **Consistency**: Keep branding generic and customizable
- **Case Usage**: 
  - UI/Display: Generic names like "Your App" (capitalized)
  - Database/Technical: Use environment variables
  - File names: Follow existing conventions (kebab-case, camelCase as appropriate)

## File Organization
- **Minimize file creation**: Do not create unnecessary files
- **Single file approach**: Keep related functionality in single files where it makes sense
- **Consolidate similar code**: Use index files to group related exports
- **Examples**:
  - All types in [src/types/index.ts](mdc:src/types/index.ts)
  - All hooks in [src/hooks/index.ts](mdc:src/hooks/index.ts)
  - All context providers in [src/context/index.tsx](mdc:src/context/index.tsx)

## Component Organization
- **Common components only**: Only keep components in [src/components/](mdc:src/components) that are common or can be used by multiple different pages
- **Page-specific components**: Keep components that are specific to a particular page in the same folder as the page in the app directory for easy accessibility and clarity
- **Co-location principle**: Components used by only one page should live next to that page, not in the global components folder

## Development Approach
- **Only do what's requested**: Do not add extra features or functionality unless explicitly asked
- **Ask for permission**: If you want to add something extra, always ask for permission first
- **Follow up questions**: If confused about requirements, ask clarifying questions
- **Stay focused**: Complete the specific task requested before suggesting improvements
- **No automatic builds**: Never run `npm run build` unless explicitly requested - the development server is already running

## Build Quality & Error Prevention
- **JSX Entity Escaping**: Always escape special characters in JSX text content to prevent React unescaped entity errors
  - Use `&apos;` for apostrophes: `you'll` ‚Üí `you&apos;ll`
  - Use `&ldquo;` and `&rdquo;` for quotes: `"quoted text"` ‚Üí `&ldquo;quoted text&rdquo;`
  - Use `&amp;` for ampersands: `A & B` ‚Üí `A &amp; B`
- **TypeScript Parameter Usage**: Remove unused parameters from function signatures instead of prefixing with underscore
  - ‚ùå WRONG: `function handleData(_unusedParam: string, data: string)`
  - ‚úÖ CORRECT: `function handleData(data: string)` and update all calls
- **Type Safety**: Never use `any` type - always provide explicit type annotations
  - ‚ùå WRONG: `const params: any = { channel: id };`
  - ‚úÖ CORRECT: `const params: { channel: string; limit?: number } = { channel: id };`
- **Suspense Boundaries**: Wrap components using `useSearchParams()` or other client-side hooks in Suspense boundaries
  - Always wrap in `<Suspense fallback={LoadingComponent}>` when using `useSearchParams()`, `useRouter()` with client-side navigation
  - Provide meaningful loading fallbacks for better UX
- **ESLint Compliance**: Follow all ESLint rules without exceptions - fix issues rather than disable rules
- **Build Verification**: Always run `npm run build` before completing tasks to ensure no build errors
- **Import Optimization**: All API routes have been refactored to use static imports for better performance and type safety

## Reporting UX & AI Responsibilities ‚úÖ UPDATED
- **Deterministic UI sections**: Compute and sort ‚ÄúTop areas to focus on‚Äù and ‚ÄúCommunication Partners‚Äù locally from instances (no AI math).
- **AI-only outputs**: 0‚Äì10 score (higher=better), trend wording, key insight, and up to two `focusExampleIndexes` (instance indexes). Always display scores out of 10 in UI.
- **Examples in DM**: Show a ‚ÄúTop flagged messages‚Äù section above the action buttons with a short snippet and an ‚ÄúOpen‚Äù link for each (use `channelId`+`messageTs`). Do not render examples as extra buttons at the bottom.
- **No placeholders**: Exclude partners with 0 instances; do not include ‚ÄúUnspecified/Group‚Äù.
- **Normalization**: Always ensure required fields exist with defaults before rendering.

### Weekly/Monthly Detailed Reports UI ‚úÖ STANDARDIZED
- Score must be shown as `x.y/10` with progress scaled 0‚Äì10 and tick marks `0 ¬∑ 5 ¬∑ 10`.
- Trend badge: üìà improving, üìâ declining, ‚û°Ô∏è stable; show signed delta.
- ‚ÄúTop areas to focus on‚Äù: Top N flags by count with emoji, name, count, percentage, description.
- ‚ÄúCommunication Partners‚Äù: Only partners with `messagesExchanged > 0`, sorted by messages, top 3.
- ‚ÄúTop flagged messages‚Äù: Snippets with deep links by `channelId` + `messageTs`, above footer/actions.
- Empty states: Friendly placeholders for no data (trends, partners, examples).

## Framework-First Approach
- **Next.js 15** - we are using nextjs 15 version
- **Use Next.js built-ins**: Always use Next.js default features like `loading.tsx`, `error.tsx`, and `not-found.tsx` for handling loading states, errors, and 404s instead of custom logic
- **Check before creating**: Always check if a component, hook, or utility already exists in the framework or codebase before creating a new one
- **Ask before building**: Must ask permission before creating new components, utilities, or logic that might already exist in the framework
- **Leverage defaults**: Prefer Next.js conventions (file-based routing, built-in components) over custom implementations

## Environment Variable Management ‚úÖ NATIVE APPROACH
- **Node.js Native**: Use Node.js 20.6.0+ native `--env-file` flag instead of dotenv package
- **No Import Timing Issues**: Native loading eliminates dotenv import order problems
- **Clean Scripts**: Scripts use `tsx --env-file=.env.local` pattern without dotenv imports
- **Environment Files**:
  - `.env.local` - Development environment variables
  - `.env.production` - Production environment variables
- **Script Pattern**:
  ```typescript
  #!/usr/bin/env tsx
  // Environment variables loaded automatically by Node.js --env-file flag
  
  console.log('üöÄ Starting script...');
  
  // Direct imports - no dotenv needed
  import { ObjectId } from 'mongodb';
  import { db } from '@/lib/db';
  ```
- **Package.json Commands**:
  ```json
  {
    "scripts": {
      "script:dev": "tsx --env-file=.env.local src/scripts/script.ts",
      "script:prod": "tsx --env-file=.env.production src/scripts/script.ts"
    }
  }
  ```

## Code Duplication Prevention
- **Check before creating**: Always search existing codebase before creating new functions, types, or database operations
- **Search locations**:
  - Functions: Check [src/lib/](mdc:src/lib), [src/hooks/index.ts](mdc:src/hooks/index.ts), and relevant component files
  - Types: Check [src/types/index.ts](mdc:src/types/index.ts) first
  - Database operations: Check [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) first
- **Reuse over recreation**: If similar functionality exists, extend or modify rather than duplicate

## Import Management & Performance ‚úÖ IMPLEMENTED
- **Static imports only**: NEVER use dynamic imports (`await import()` or `require()`) in API routes
- **Top-level imports**: All imports must be declared at the top of the file for optimal performance
- **Build-time optimization**: Static imports enable better tree-shaking and bundle optimization
- **Common import patterns**:
  ```typescript
  // ‚úÖ CORRECT - Static imports at top
  import { NextRequest, NextResponse } from 'next/server';
  import { ObjectId } from 'mongodb';
  import { workspaceCollection } from '@/lib/db';
  import { WebClient } from '@slack/web-api';
  
  export async function POST(request: NextRequest) {
    // Use imports directly without dynamic loading
    const workspace = await workspaceCollection.findOne({ _id: new ObjectId(id) });
    const slack = new WebClient(token);
  }
  
  // ‚ùå WRONG - Dynamic imports (performance penalty)
  export async function POST(request: NextRequest) {
    const { ObjectId } = await import('mongodb');
    const { workspaceCollection } = await import('@/lib/db');
  }
  ```
- **Type safety benefits**: Static imports provide better TypeScript inference and error checking
- **Consistency**: All API routes in [src/app/api/](mdc:src/app/api) follow this pattern

## UI Component Architecture
- **Mantine as base**: Always use Mantine library components as the foundation
- **Wrapper pattern**: Create wrapper components in [src/components/ui/](mdc:src/components/ui) to prevent vendor lock-in
- **NEVER use Mantine directly**: NEVER import or use Mantine components directly in any application code. ALL Mantine components must be wrapped in UI components first
- **UI components only**: Always import components from `@/components/ui` - never from `@mantine/core` or any other UI library
- **NO RAW DIVS**: Never use raw `<div>` elements - always use appropriate Mantine wrapper components like `Stack`, `Row`, `Center`, `Card`, etc.
- **Forward refs**: Always use `forwardRef` for UI components to maintain ref compatibility
- **Export pattern**: Export wrapped components from [src/components/ui/index.ts](mdc:src/components/ui/index.ts)
- **Next.js components**: Wrap Next.js components (Link, Image, etc.) with custom components using `forwardRef` to maintain fixed values and consistency
- **Layout Components**: Use semantic Mantine components for all layout needs:
  - `<Stack>` for vertical layouts
  - `<Row>` (Group wrapper) for horizontal layouts  
  - `<Center>` for centering content
  - `<Container>` for page-level containers
- **Example structures**:
  ```typescript
  // ‚ùå WRONG - Never do this
  import { Button, Text, Stack } from '@mantine/core';
  
  // ‚ùå WRONG - Never use raw divs
  <div style={{ display: 'flex', justifyContent: 'center' }}>
    <div style={{ padding: 20 }}>Content</div>
  </div>
  
  // ‚úÖ CORRECT - Always do this
  import { Button, Text, Stack, Row, Center } from '@/components/ui';
  
  <Row justify="center">
    <Stack p={20}>Content</Stack>
  </Row>
  ```

## Mantine UI Setup

### Configuration Files
- **Theme Configuration**: [src/lib/theme.ts](mdc:src/lib/theme.ts) - Professional color palette with primary blue, secondary teal, accent orange, and status colors
- **PostCSS Setup**: [postcss.config.cjs](mdc:postcss.config.cjs) - Mantine preset and responsive breakpoint variables
- **Layout Integration**: [src/app/layout.tsx](mdc:src/app/layout.tsx) - MantineProvider, ColorSchemeScript, and theme application
- **Next.js Optimization**: [next.config.ts](mdc:next.config.ts) - Package import optimization for Mantine components

### Usage
- Always use theme colors from [src/lib/theme.ts](mdc:src/lib/theme.ts) instead of arbitrary colors
- Components are pre-configured with professional defaults (radius, shadows, sizes)
- Follow UI component architecture rules for creating wrapper components

## UI Components Inventory

### Core UI Components
- **Button** - [src/components/ui/Button.tsx](mdc:src/components/ui/Button.tsx) - Basic button wrapper with forwardRef
- **LoadingButton** - [src/components/ui/LoadingButton.tsx](mdc:src/components/ui/LoadingButton.tsx) - Button with built-in loading states and Lucide icons
- **TextInput** - [src/components/ui/TextInput.tsx](mdc:src/components/ui/TextInput.tsx) - Text input wrapper
- **Textarea** - [src/components/ui/Textarea.tsx](mdc:src/components/ui/Textarea.tsx) - Textarea wrapper
- **Card** - [src/components/ui/Card.tsx](mdc:src/components/ui/Card.tsx) - Card wrapper
- **AnimatedCard** - [src/components/ui/AnimatedCard.tsx](mdc:src/components/ui/AnimatedCard.tsx) - Card with hover and click animations
- **LoadingOverlay** - [src/components/ui/LoadingOverlay.tsx](mdc:src/components/ui/LoadingOverlay.tsx) - Loading overlay wrapper

### Layout Components
- **Container** - [src/components/ui/Container.tsx](mdc:src/components/ui/Container.tsx) - Container wrapper
- **Stack** - [src/components/ui/Stack.tsx](mdc:src/components/ui/Stack.tsx) - Stack layout wrapper
- **Center** - [src/components/ui/Center.tsx](mdc:src/components/ui/Center.tsx) - Center alignment wrapper

### Typography Components
- **Title** - [src/components/ui/Title.tsx](mdc:src/components/ui/Title.tsx) - Title/heading wrapper
- **Text** - [src/components/ui/Text.tsx](mdc:src/components/ui/Text.tsx) - Text wrapper

### Navigation Components
- **Link** - [src/components/ui/Link.tsx](mdc:src/components/ui/Link.tsx) - Next.js Link wrapper with fixed prefetch=false

### Form Components
- **FormField** - [src/components/ui/FormField.tsx](mdc:src/components/ui/FormField.tsx) - Reusable form field with label, description, and error handling
- **ErrorMessage** - [src/components/ui/ErrorMessage.tsx](mdc:src/components/ui/ErrorMessage.tsx) - Error alert with Lucide AlertCircle icon
- **SuccessMessage** - [src/components/ui/SuccessMessage.tsx](mdc:src/components/ui/SuccessMessage.tsx) - Success alert with Lucide CheckCircle icon

### Loading Components
- **Skeleton** - [src/components/ui/Skeleton.tsx](mdc:src/components/ui/Skeleton.tsx) - Basic skeleton wrapper
- **FormSkeleton** - [src/components/ui/FormSkeleton.tsx](mdc:src/components/ui/FormSkeleton.tsx) - Specialized skeleton for forms with configurable fields

### Animation Components
- **FadeIn** - [src/components/ui/FadeIn.tsx](mdc:src/components/ui/FadeIn.tsx) - Smooth fade-in animation with customizable delay and duration
- **AnimatedCard** - Already listed above in Core UI Components

### Component Export Index
- **All components exported from**: [src/components/ui/index.ts](mdc:src/components/ui/index.ts)

### Usage Guidelines for UI Components
- **Import pattern**: Always import from the index file: `import { Button, TextInput } from '@/components/ui';`
- **Lucide icons**: All icon components use Lucide React icons (pre-installed)
- **ForwardRef compatibility**: All components support ref forwarding
- **TypeScript types**: All components export proper TypeScript interfaces/types
- **Mantine foundation**: All components wrap Mantine components to prevent vendor lock-in

## Color Scheme Management
- **Use predefined colors only**: Never use random or hardcoded colors
- **Color source**: All colors must come from the established color scheme configuration
- **Configuration location**: Colors defined in theme/config files (to be determined)
- **No arbitrary colors**: Avoid using arbitrary Tailwind colors or CSS color values
- **Consistency**: Maintain visual consistency across all components and pages

## Subscription System & Pricing Management ‚úÖ CENTRALIZED
- **Single Source of Truth**: All subscription data managed in [src/types/index.ts](mdc:src/types/index.ts) `SUBSCRIPTION_TIERS` object
- **No Hardcoded Features**: Never hardcode pricing, features, or descriptions in UI components
- **Dynamic UI Content**: All pricing cards, feature lists, and descriptions pull from `SUBSCRIPTION_TIERS`
- **Easy Updates**: Change pricing, features, or descriptions in one place to update everywhere
- **Consistent Display**: Both onboarding and landing page use identical subscription data
- **Feature Structure**: Each tier includes:
  ```typescript
  {
    name: 'Free',
    price: 0,
    description: 'Quick start with core coaching.',
    priceLabel: '/ forever',
    displayFeatures: [
      {
        name: 'Feature name',
        description: 'Feature description',
        included: true,
        limit?: 50,
        limitLabel: 'Display text'
      }
    ]
  }
  ```
- **Usage Pattern**: Always import and use `SUBSCRIPTION_TIERS` from types:
  ```typescript
  import { SUBSCRIPTION_TIERS } from '@/types';
  
  // ‚úÖ CORRECT - Dynamic content
  <Text>{SUBSCRIPTION_TIERS.FREE.description}</Text>
  {SUBSCRIPTION_TIERS.FREE.displayFeatures.map(feature => (
    <Text key={feature.name}>{feature.limitLabel}</Text>
  ))}
  
  // ‚ùå WRONG - Hardcoded content
  <Text>Quick start with core coaching.</Text>
  <Text>50 auto coaching/month</Text>
  ```

## Database Architecture
- **Use Native MongoDB Driver**: The project uses MongoDB's native Node.js driver (not Mongoose)
- **Database Connection**: MongoDB client is configured in [src/lib/db.ts](mdc:src/lib/db.ts)
- **Database Name**: Use `process.env.MONGODB_DB_NAME` for database name
- **No ODM/ORM**: Direct MongoDB operations without abstraction layer
- **Server Actions**: All database operations should be in Server Actions in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts)
- **Collection Operations**: Use native MongoDB collection methods (insertOne, findOne, updateOne, etc.)

## Authentication & Slack Integration Architecture
- **Slack OAuth**: Direct Slack app installation without traditional web authentication
- **Workspace-Specific Tokens**: Each workspace has its own bot token stored during OAuth installation
- **Bot Token Storage**: Workspace-specific `botToken` field in workspaceCollection enables per-workspace API calls
- **Channel Access Control**: Bot operates in any channel where it's added (onboarding or manual addition)
- **Authorization Strategy**: Simple database presence check - if user exists in database, they're authorized
- **Authentication Flow**:
  1. **Website Install**: User clicks "Install to Slack" ‚Üí OAuth ‚Üí Database entry ‚Üí Full access
  2. **Direct Install**: User installs from Slack App Directory ‚Üí OAuth ‚Üí Database entry ‚Üí Full access
  3. **Command Authorization**: If user NOT in database ‚Üí Show authorization message with website redirect
- **Token Usage**: All Slack API calls use workspace-specific tokens from database
- **No Web Sessions**: Standard Slack app approach - all data tied to Slack user IDs

## Slack Event Handling & Auto Coaching ‚úÖ IMPLEMENTED

### Event Subscription Strategy
- **Privacy by Design**: Bot only receives events from channels where it's explicitly added as a member
- **Event Types Required**: 
  - `message.channels` - Public channel messages (REQUIRED for auto coaching)  
  - `message.groups` - Private channel messages
  - `member_joined_channel` - Bot added to channels (updates database)
  - `channel_left` - **UPDATED**: Bot leaves public channels (replaces `member_left_channel`)
  - `group_left` - **NEW**: Bot leaves private channels/groups
  - `app_mention` - @bot mentions
- **Channel Filtering**: Slack automatically filters events to only channels where bot is member
- **Database Verification**: `botChannelsCollection` kept in sync via join/leave events

### Event-Driven Channel Management ‚úÖ UPDATED ARCHITECTURE
- **Single Source of Truth**: Slack events drive ALL channel membership changes
- **Automatic Sync**: Database updated whenever bot joins/leaves channels (onboarding or manual)
- **No Manual Database Operations**: Onboarding only joins channels, events handle persistence
- **Event Handlers**: 
  - `handleBotJoinedChannel()` - Adds channel to `botChannelsCollection` when bot joins + sends notifications
  - `handleBotLeftChannel()` - Removes channel from `botChannelsCollection` when bot leaves
  - Bot user ID verification only needed for `member_joined_channel` (other events are bot-specific)
- **Channel Access**: `isChannelAccessible()` checks database, always accurate due to event sync
- **Correct Bot Departure Events**: Uses `channel_left`/`group_left` instead of `member_left_channel`

### Auto Coaching Implementation ‚úÖ WORKING
- **Real-time Analysis**: Message events trigger AI analysis for communication improvement
- **Ephemeral Feedback**: Private suggestions only visible to message sender
- **Interactive Components**: "Replace Message" and "Keep Original" buttons
- **Workspace-Specific Tokens**: Each workspace uses its own bot token for API calls
- **Channel Access Control**: Event-driven database sync ensures accurate channel membership tracking

### Message Event Processing Flow
```typescript
// 1. Slack sends event (only from member channels)
if (event.type === 'message' && (event.channel_type === 'channel' || event.channel_type === 'group')) {
  
  // 2. Validate user has app installed
  const user = await slackUserCollection.findOne({ slackId: event.user, isActive: true });
  if (!user) return; // Skip - user hasn't installed app
  
  // 3. Verify bot is active in specific channel  
  const isChannelActive = await isChannelAccessible(event.channel, user.workspaceId);
  if (!isChannelActive) return; // Skip - not authorized channel
  
  // 4. Get workspace-specific bot token
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  if (!workspace?.botToken) return; // Skip - missing token
  
  // 5. AI analysis and ephemeral coaching feedback
  // 6. Interactive message replacement functionality
}
```

## Slack Scope Management & Troubleshooting ‚úÖ CRITICAL
- **Required Bot Scopes**: All Slack functionality depends on having correct bot token scopes configured
- **Scope Configuration Files**:
  - Code: [src/lib/slack.ts](mdc:src/lib/slack.ts) - `slackOAuthConfig.botScopes` array  
  - Manifest: [manifest-dev.json](mdc:manifest-dev.json) and [manifest-prod.json](mdc:manifest-prod.json) - `settings.event_subscriptions.bot_events` array
- **Critical Scopes for Core Functionality**:
  - `chat:write` - Send messages to channels (REQUIRED)
  - `chat:write.customize` - Custom username/avatar for message replacement
  - `im:write` - Send direct messages to users (REQUIRED for welcome messages)
  - `message.channels` event subscription requires proper scopes
- **Common Issues Fixed**:
  - Missing `message.channels` in event subscriptions (prevented auto coaching)
  - Incorrect interactive endpoint URL (`/interactions` vs `/interactive`)
  - Missing `chat:write.customize` scope for message replacement
  - Using global bot token instead of workspace-specific tokens
- **Troubleshooting Process**:
  1. Check error logs for `missing_scope` messages
  2. Identify which API method is failing
  3. Look up required scopes in Slack API docs
  4. Add missing scopes to both `src/lib/slack.ts` and manifest files (`manifest-dev.json`, `manifest-prod.json`)
  5. Update Slack app configuration in developer console
  6. Reinstall app to get new permissions
- **Essential Bot Scopes List**:
  ```typescript
  botScopes: [
    'chat:write',        // Send messages
    'chat:write.public', // Send to channels bot isn't in
    'chat:write.customize', // Custom username/avatar for replacements
    'commands',          // Slash commands
    'channels:history',  // Read message history
    'groups:history',    // Read private channel history  
    'channels:read',     // Read channel info
    'channels:join',     // Join channels during onboarding
    'groups:read',       // Read private channel info
    'im:write',          // Send DMs (CRITICAL for welcome messages)
    'users:read',        // Read user info
    'app_mentions:read'  // Handle @mentions
  ]
  ```

## Welcome Message Implementation ‚úÖ COMPLETED
- **Functionality**: Personalized welcome message sent via DM after Slack app installation
- **Implementation**: [src/lib/slack.ts](mdc:src/lib/slack.ts) - `sendWelcomeMessage()` function
- **Integration**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts) - Called after OAuth success
- **Message Features**:
  - Rich Block Kit formatting with interactive buttons
  - "Complete Setup" button linking to onboarding
  - "Help Center" button for documentation  
  - Clear value proposition and next steps
  - Privacy reassurance (feedback is private)
- **Error Handling**: Graceful failure - doesn't break OAuth flow if DM fails
- **Critical Dependency**: Requires `im:write` scope for DM functionality
- **Follow-up System**: `sendOnboardingReminderMessage()` for incomplete users

## API Architecture
- **Use Server Actions**: Prefer Next.js Server Actions over API routes for most functionality
- **API routes only for**:
  - Slack OAuth callback and webhook endpoints
  - Slack commands, events, and interactive components
  - Webhook endpoints from external services
  - Third-party integrations that require traditional REST endpoints
  - Demo bots and testing endpoints (e.g., `/api/demo`)
- **Server Actions for**:
  - Database operations (with workspace-specific token lookups)
  - Form submissions and onboarding flow
  - Data mutations and channel management
  - Business logic and AI operations
- **Workspace Token Pattern**: Server actions fetch workspace-specific bot tokens from database before making Slack API calls
- **Demo Bot Pattern**: Simple single-file implementations in `/api/demo` with separate environment variables and minimal dependencies
- **Import Standards**: All API routes use static imports only - see Import Management section for details

## Project Structure Reference
- **Auth pages**: [src/app/(auth)/](mdc:src/app/(auth)/) - Login, register, etc.
- **App pages**: [src/app/app/](mdc:src/app/app) - Protected application pages (no route group)
- **Public pages**: [src/app/(public)/](mdc:src/app/(public)/) - Landing and public pages
- **API routes**: [src/app/api/](mdc:src/app/api) - Only for auth and specific endpoints
- **Components**: [src/components/](mdc:src/components) - Organized by section (ui, auth, app, common)
- **Server Actions**: [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) for shared database operations

## Current Implementation Snapshot (January 2025)

_This snapshot helps you quickly navigate the existing codebase. It will become outdated as files change, so update it when major structural changes occur._

### Root Directories
- **Source code**: [src/](mdc:src)
  - **Application routes**: [src/app/](mdc:src/app)
  - **Shared libraries & helpers**: [src/lib/](mdc:src/lib)
  - **Global React context**: [src/context/](mdc:src/context) (currently empty)
  - **Reusable components**: [src/components/](mdc:src/components)
  - **Type definitions**: [src/types/](mdc:src/types)
  - **Custom hooks**: [src/hooks/](mdc:src/hooks)

### Key Route Groups
1. **Public Pages** ‚Äî [src/app/(public)/](mdc:src/app/(public)/) 
   - Landing page with Slack installation: [src/app/(public)/page.tsx](mdc:src/app/(public)/page.tsx)
   - Marketing and public content

2. **App Pages** ‚Äî [src/app/app/](mdc:src/app/app) (no auth needed - Slack app)
   - Onboarding flow: [src/app/app/onboarding/page.tsx](mdc:src/app/app/onboarding/page.tsx)
   - Help documentation: [src/app/app/docs/page.tsx](mdc:src/app/app/docs/page.tsx) (moved from /help to /docs)  
   - Team invitations: [src/app/app/invite/page.tsx](mdc:src/app/app/invite/page.tsx)

3. **API Routes** ‚Äî [src/app/api/](mdc:src/app/api) ‚úÖ OPTIMIZED
   - Slack OAuth callback: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts)
   - Slack commands: [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts)
   - Slack events: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts)
   - Slack interactive: [src/app/api/slack/interactive/route.ts](mdc:src/app/api/slack/interactive/route.ts)
   - Stripe checkout: [src/app/api/stripe/checkout/route.ts](mdc:src/app/api/stripe/checkout/route.ts)
   - Stripe portal: [src/app/api/stripe/portal/route.ts](mdc:src/app/api/stripe/portal/route.ts)
   - Stripe webhooks: [src/app/api/stripe/webhooks/route.ts](mdc:src/app/api/stripe/webhooks/route.ts)
   - Demo bot: [src/app/api/demo/route.ts](mdc:src/app/api/demo/route.ts) - Single-file AI reply bot for testing
   - **Import Standard**: All routes use static imports for optimal performance and type safety

### Middleware & Authentication
- **Middleware**: [src/middleware.ts](mdc:src/middleware.ts) - Protects `/app/*` routes with session validation and onboarding flow
- **Auth Configuration**: [src/lib/auth.ts](mdc:src/lib/auth.ts) - Better-auth setup
- **Auth Client**: [src/lib/auth-client.ts](mdc:src/lib/auth-client.ts) - Browser-side auth utilities

### Library & Utility Files
- **MongoDB client**: [src/lib/db.ts](mdc:src/lib/db.ts) - Native MongoDB driver connection
- **Server actions**: [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) - Database operations and business logic
- **AI Integration**: [src/lib/ai.ts](mdc:src/lib/ai.ts) - Azure OpenAI powered AI functions for auto-coaching
- **AI Prompts**: [src/lib/prompts/index.ts](mdc:src/lib/prompts/index.ts) - Centralized AI prompt templates (includes contextual variants for rephrase)
- **Reports System**: [src/lib/report-utils.ts](mdc:src/lib/report-utils.ts) - Optimized report generation utilities with incremental approach
- **Theme configuration**: [src/lib/theme.ts](mdc:src/lib/theme.ts)
- **Utilities**: [src/lib/utils.ts](mdc:src/lib/utils.ts)

### API Routes
- **Auth**: [src/app/api/auth/[...all]/route.ts](mdc:src/app/api/auth/[...all]/route.ts) - Better-auth handler

### UI Component Folders
- **UI wrappers**: [src/components/ui/](mdc:src/components/ui) - Comprehensive UI component library
- **Reports components**: [src/components/reports/](mdc:src/components/reports) - Report viewing components for weekly/monthly reports
- **Auth-specific components**: [src/components/auth/](mdc:src/components/auth) (currently empty)

### Scripts & Background Jobs
- **Report Generation**: [src/app/scripts/](mdc:src/app/scripts/) - Optimized weekly/monthly report generation scripts
  - **Weekly**: [src/app/scripts/generate-weekly-reports.ts](mdc:src/app/scripts/generate-weekly-reports.ts) - Incremental weekly report generation
  - **Monthly**: [src/app/scripts/generate-monthly-reports.ts](mdc:src/app/scripts/generate-monthly-reports.ts) - Incremental monthly report generation
  - **Testing**: [src/app/scripts/test-reports.ts](mdc:src/app/scripts/test-reports.ts) - System validation and testing
  - **Environment-aware**: Uses `.env.local` for dev, `.env.production` for prod via `NODE_ENV`
  - **Proper termination**: All scripts use `process.exit()` to prevent hanging

### Report Pages
- **Weekly Reports**: [src/app/reports/weekly/[id]/page.tsx](mdc:src/app/reports/weekly/[id]/page.tsx) - Dynamic weekly report pages
- **Monthly Reports**: [src/app/reports/monthly/[id]/page.tsx](mdc:src/app/reports/monthly/[id]/page.tsx) - Dynamic monthly report pages
- **Security**: Long unguessable IDs, no authentication required
- **Analytics**: Pre-calculated chart data with current vs previous period comparisons

### Data & Types
- **Type definitions**: [src/types/index.ts](mdc:src/types/index.ts) - Simplified Zod schemas and TypeScript types including optimized `ReportSchema`
- **No Mongoose Models**: Database operations use native MongoDB driver with Zod schemas for validation

### Styling & Theme
- **Global CSS**: [src/app/globals.css](mdc:src/app/globals.css)
- **Mantine Provider & fonts**: [src/app/layout.tsx](mdc:src/app/layout.tsx)

## Validation & Schema Management
- **Use Zod for validation**: Always use Zod schemas for data validation instead of manual checking
- **Schema location**: Define Zod schemas in [src/types/index.ts](mdc:src/types/index.ts) alongside TypeScript interfaces
- **Validation pattern**: Create Zod schemas that can infer TypeScript types, ensuring single source of truth
- **Server actions**: Use Zod schemas to validate inputs in server actions before processing
- **Form validation**: Use Zod schemas with form libraries for client-side validation
- **API validation**: Validate all incoming data using Zod schemas
- **Database validation**: Use Zod schemas to validate data before MongoDB operations
- **Example pattern**:
  ```typescript
  // Define Zod schema first
  export const UserConfigSchema = z.object({
    websiteUrl: z.string().url(),
    companyName: z.string().min(1),
    // ... other fields
  });
  
  // Infer TypeScript type from schema
  export type UserConfig = z.infer<typeof UserConfigSchema>;
  
  // Use in MongoDB operations
  const validatedData = UserConfigSchema.parse(rawData);
  await db.collection('configs').insertOne(validatedData);
  ```

## Onboarding Flow Implementation ‚úÖ UPDATED (Private Channel Filtering)
- **Multi-step form**: [src/app/app/onboarding/OnboardingForm.tsx](mdc:src/app/app/onboarding/OnboardingForm.tsx) handles Slack user onboarding
- **User Identification**: Query parameters (`?user={slackId}&team={teamId}`) for validation
- **Step Flow**: `frequency` ‚Üí `channels` ‚Üí `payment` ‚Üí complete
  - **Step 1**: Analysis frequency selection (weekly/monthly)
  - **Step 2**: Channel selection - users choose which channels to enable AI coaching ‚úÖ **PRIVATE CHANNELS FILTERED OUT**
  - **Step 3**: Payment plan selection - Free vs Pro with dynamic pricing cards

### Channel Selection Enhancement ‚úÖ NEW
- **Private Channel Filtering**: Only shows public channels in onboarding (bots can't join private channels via API)
- **Filter Logic**: `!channel.is_archived && !channel.is_private` in channel selection
- **User Experience**: Prevents confusion and API errors from attempting to join private channels
- **Default Behavior**: Auto-coaching enabled by default in all selected (public) channels
- **Payment Step Features**:
  - **Congratulations Message**: "üéâ You're all set up! Get even more features with our Pro plan."
  - **Side-by-Side Cards**: FREE and PRO plans using `SUBSCRIPTION_TIERS` data
  - **Dynamic Container Width**: Adjusts from 480px to 640px for payment step to accommodate horizontal cards
  - **Mantine Layout**: Uses `Row justify="center"` with proper flex properties for horizontal card display
  - **Button Actions**: 
    - Free: "Continue with Free" ‚Üí completes onboarding ‚Üí `/app/docs`
    - Pro: "Upgrade to Pro" ‚Üí Stripe checkout ‚Üí `/app/docs` after success
- **Server Actions**: 
  - `validateSlackUser()` - Validates user and checks onboarding status
  - `getWorkspaceChannels()` - Fetches available channels using workspace-specific bot token
  - `joinBotToChannels()` - Joins bot to selected channels (database updates via events)
  - `completeSlackOnboarding()` - Saves preferences, channels, and marks onboarding complete
- **Layout Patterns**:
  - **Container Responsive Width**: `maxWidth: currentStep === 'payment' ? 640 : 480`
  - **Card Flex Properties**: `minWidth: 280, maxWidth: 280, flexShrink: 0`
  - **Row Layout**: `<Row justify="center" gap={24} wrap="wrap" align="stretch">`
- **One-time completion**: `hasCompletedOnboarding` flag prevents re-access
- **Bot Integration**: Bot automatically joins selected channels during onboarding
- **Completion**: Sets `hasCompletedOnboarding: true` on user document for middleware routing

## Key Collections ‚úÖ UPDATED
- **workspaceCollection**: Slack workspace/team data (workspaceId, name, domain, **botToken**)
- **slackUserCollection**: Slack user data with onboarding tracking and **subscription** field (slackId, analysisFrequency, hasCompletedOnboarding, **subscription**)
- **botChannelsCollection**: Tracks which channels bot is active in (workspaceId, channelId, channelName, addedAt) - **Updated via Slack events**
- **invitationCollection**: Email invitations sent by users during onboarding
- **analysisInstanceCollection**: Future - will store message analysis results
- **Legacy collections**: userCollection, accountConfigCollection (for reference only)

## Payment & Subscription Architecture ‚úÖ IMPLEMENTED

### Subscription System Overview
- **Provider**: Stripe for payment processing and subscription management
- **Tiers**: FREE (default) and PRO (paid) tiers with feature limits
- **Billing**: Monthly billing cycles with automatic usage reset
- **User-Based**: All limits and pricing are per-user, not per-workspace
- **No Admin Dashboard**: Backend-only implementation with Stripe handling UI

### Subscription Configuration ‚úÖ CENTRALIZED
- **Configuration Location**: [src/types/index.ts](mdc:src/types/index.ts) - All subscription types, tiers, and pricing
- **Subscription Tiers**:
  ```typescript
  export const SUBSCRIPTION_TIERS = {
    FREE: {
      name: 'Free',
      price: 0,
      monthlyLimits: {
        autoCoaching: 50,      // Auto coaching suggestions
        manualRephrase: 10,    // Manual /rephrase commands  
        personalFeedback: 2,   // Personal feedback reports
      },
      features: {
        basicAnalysis: true,   // Basic AI analysis
        weeklyReports: false,  // Weekly communication reports
        prioritySupport: false // Priority customer support
      }
    },
    PRO: {
      name: 'Pro',
      price: 2000, // $20.00 in cents
      monthlyLimits: {
        autoCoaching: -1,      // Unlimited
        manualRephrase: -1,    // Unlimited
        personalFeedback: -1,  // Unlimited
      },
      features: {
        basicAnalysis: true,
        weeklyReports: true,
        prioritySupport: true
      }
    }
  } as const;
  ```

### Database Schema Integration ‚úÖ IMPLEMENTED
- **Subscription Field**: Added to `SlackUserSchema` in [src/types/index.ts](mdc:src/types/index.ts)
- **Schema Structure**:
  ```typescript
  export const SubscriptionSchema = z.object({
    tier: z.enum(['FREE', 'PRO']).default('FREE'),
    status: z.enum(['active', 'cancelled', 'past_due']).default('active'),
    currentPeriodStart: z.coerce.date(),
    currentPeriodEnd: z.coerce.date(),
    stripeCustomerId: z.string().optional(),
    stripeSubscriptionId: z.string().optional(),
    monthlyUsage: z.object({
      autoCoaching: z.number().default(0),
      manualRephrase: z.number().default(0),
      personalFeedback: z.number().default(0),
    }),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
  });
  ```

### Subscription Management Functions ‚úÖ IMPLEMENTED
- **Location**: [src/lib/subscription.ts](mdc:src/lib/subscription.ts) - Individual server functions
- **Core Functions**:
  - `validateUserAccess(userId, feature)` - Check subscription limits and access
  - `incrementUsage(userId, feature)` - Track feature usage
  - `updateSubscription(userId, updates)` - Update subscription data
  - `resetMonthlyUsage(userId)` - Reset usage counters for new billing period
  - `getSubscriptionStatus(userId)` - Get current subscription and usage info
  - `needsBillingReset(userId)` - Check if billing period reset is needed

### Access Control Integration ‚úÖ IMPLEMENTED
- **Command Integration**: All Slack commands check subscription limits before processing
- **Auto Coaching**: Event handler validates access before AI analysis
- **Usage Tracking**: Increment counters after successful feature usage
- **Rate Limiting**: Monthly limits enforced with user-friendly messages

### Stripe Integration ‚úÖ IMPLEMENTED

#### Stripe Configuration
- **Client Setup**: [src/lib/stripe.ts](mdc:src/lib/stripe.ts) - Stripe client with API version `2025-07-30.basil`
- **Price IDs**: Defined in [src/types/index.ts](mdc:src/types/index.ts) for environment-specific pricing
- **Webhook Endpoint**: [src/app/api/stripe/webhooks/route.ts](mdc:src/app/api/stripe/webhooks/route.ts)

#### Stripe API Endpoints
- **Checkout**: [src/app/api/stripe/checkout/route.ts](mdc:src/app/api/stripe/checkout/route.ts) - Create checkout sessions
- **Customer Portal**: [src/app/api/stripe/portal/route.ts](mdc:src/app/api/stripe/portal/route.ts) - Manage subscriptions
- **Webhooks**: [src/app/api/stripe/webhooks/route.ts](mdc:src/app/api/stripe/webhooks/route.ts) - Handle Stripe events

#### Webhook Event Handling ‚úÖ ENHANCED
- **Supported Events**:
  - `checkout.session.completed` - New subscription creation **with existing subscription sync**
  - `customer.subscription.created` - Subscription activation
  - `customer.subscription.updated` - Subscription changes
  - `customer.subscription.resumed` - Subscription resumption
  - `customer.subscription.deleted` - Subscription cancellation
  - `customer.updated` - Customer portal interactions (fallback sync)
  - `invoice.payment_succeeded` - Successful payment processing
  - `invoice.payment_failed` - Failed payment handling
- **Enhanced Checkout Handling**: Proactively syncs existing subscriptions when no webhook is sent
- **Customer Portal Support**: Handles "Use existing subscription" flow without webhook events

#### Type Safety with Stripe ‚úÖ RESOLVED
- **Challenge**: Stripe TypeScript definitions don't include all runtime properties
- **Solution**: Use proper type casting for accessing runtime properties
- **Pattern**:
  ```typescript
  // Access properties that exist at runtime but not in TypeScript definitions
  const subscriptionData = subscription as unknown as Record<string, unknown>;
  const currentPeriodStart = subscriptionData.current_period_start as number;
  
  const invoiceData = invoice as unknown as Record<string, unknown>;
  const subscriptionId = invoiceData.subscription as string;
  ```

### User Initialization ‚úÖ IMPLEMENTED
- **OAuth Integration**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts)
- **Default Subscription**: New users get FREE tier with active status and zero usage
- **Initialization Pattern**:
  ```typescript
  const defaultSubscription = {
    tier: 'FREE' as const,
    status: 'active' as const,
    currentPeriodStart: new Date(),
    currentPeriodEnd: nextMonth,
    monthlyUsage: {
      autoCoaching: 0,
      manualRephrase: 0,
      personalFeedback: 0,
    },
    createdAt: new Date(),
    updatedAt: new Date(),
  };
  ```

### Feature Access Patterns ‚úÖ IMPLEMENTED

#### Pre-Feature Validation
```typescript
// Before processing any feature
const accessCheck = await validateUserAccess(userId, 'autoCoaching');
if (!accessCheck.allowed) {
  if (accessCheck.upgradeRequired) {
    return generateUpgradeMessage('autoCoaching', accessCheck.reason, userId);
  }
  return generateLimitReachedMessage('autoCoaching', currentUsage, limit, resetDate, userId);
}
const user = accessCheck.user!; // User is included in successful validation
```

#### Post-Feature Usage Tracking
```typescript
// After successful feature usage (in background)
after(async () => {
  if (success) {
    await incrementUsage(userId, 'autoCoaching');
  }
});
```

### User Experience Messages ‚úÖ IMPLEMENTED
- **Upgrade Messages**: Professional upgrade prompts with Stripe checkout links
- **Limit Reached**: Friendly messages showing current usage and reset dates
- **Slack Formatting**: Uses proper Slack mrkdwn formatting (`*bold*`, `_italic_`)

### Billing Cycle Management ‚úÖ IMPLEMENTED
- **Monthly Reset**: Usage counters reset on billing anniversary date
- **Automatic Processing**: Webhook handlers manage billing period updates
- **Grace Period**: No interruption during payment processing

### Environment Configuration
- **Stripe Keys**: `STRIPE_SECRET_KEY`, `STRIPE_PUBLISHABLE_KEY`, `STRIPE_WEBHOOK_SECRET`
- **Price IDs**: Environment-specific Stripe price identifiers
- **Database**: Subscription data stored in existing MongoDB collections

### Best Practices ‚úÖ ENFORCED
- **Single User Fetch**: `validateUserAccess` fetches user once and includes in result
- **Background Processing**: Usage tracking happens in `after()` blocks
- **Type Safety**: Proper Zod validation for all subscription data
- **Error Handling**: Graceful degradation when Stripe operations fail
- **Consistency**: All subscription logic centralized in dedicated functions

## Trigger.dev Background Jobs Architecture

### What is Trigger.dev?
**Trigger.dev** is a powerful background job and AI infrastructure platform that enables developers to write reliable, long-running workflows in normal async code. It handles queues, elastic scaling, retries, observability, and zero infrastructure management.

**Key Features:**
- **No timeouts**: Write simple, reliable code that never hits timeouts
- **Pay for what you use**: Only pay when code is actually executing
- **No servers to manage**: Automatic deployment and scaling
- **Observability**: Real-time monitoring and tracing of tasks
- **Retries**: Automatic retrying with configurable strategies
- **AI integration**: Built-in support for AI agents and LLM workflows

**Documentation**: [https://trigger.dev/docs](https://trigger.dev/docs)

### Project Integration

#### Configuration
- **Config file**: [trigger.config.ts](mdc:trigger.config.ts) - Main Trigger.dev configuration
- **Task location**: [src/trigger/](mdc:src/trigger/) - All background tasks
- **Environment variables**: Use `TRIGGER_API_KEY` and `TRIGGER_API_URL` for deployment

#### Task Structure
```typescript
// Example task pattern
import { task } from "@trigger.dev/sdk/v3";

export const exampleTask = task({
  id: "example-task",
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 5000,
  },
  run: async (payload, { ctx }) => {
    // Your async logic here
    console.log("Task executed:", payload);
    
    return { success: true, data: "Task completed" };
  },
});
```

#### Current Implementation
- **Generic task**: [src/trigger/generateCreative.ts](mdc:src/trigger/generateCreative.ts) - Simplified example task
- **Task ID**: Uses environment variable `TRIGGER_TASK_ID` for generic naming
- **Purpose**: Demonstrates basic Trigger.dev integration pattern

#### Best Practices
- **Task naming**: Use descriptive, generic names that can be reused
- **Error handling**: Implement proper error handling with retry logic
- **Payload validation**: Validate input payloads using Zod schemas
- **Logging**: Use structured logging for observability
- **Environment separation**: Use different task IDs for dev/prod environments

#### Common Use Cases
- **AI workflows**: Long-running AI operations with LLM chains
- **Data processing**: Batch operations and ETL processes
- **Scheduled tasks**: Cron jobs and periodic operations
- **Webhook processing**: Handle external service webhooks
- **Email campaigns**: Bulk email processing and delivery
- **File processing**: Image, video, and document processing

#### Development Workflow
1. **Local development**: Use Trigger.dev CLI for local testing
2. **Task deployment**: Deploy tasks to Trigger.dev cloud
3. **Monitoring**: Use Trigger.dev dashboard for observability
4. **Debugging**: Use run logs and tracing for troubleshooting

#### Integration with Next.js
- **Server Actions**: Trigger tasks from server actions
- **API Routes**: Use for webhook endpoints that trigger tasks
- **Client-side**: Use Trigger.dev React hooks for real-time updates
- **Environment**: Configure for different deployment environments

## Azure OpenAI Integration ‚úÖ IMPLEMENTED

### Configuration
- **Provider**: Azure OpenAI using official `openai` SDK with `AzureOpenAI` client
- **Environment Variables**:
  - `AZURE_API_KEY` - Azure OpenAI API key (required)
  - `AZURE_API_ENDPOINT` - Azure endpoint URL (required)
  - `AZURE_API_VERSION` - API version (defaults to '2024-12-01-preview')
  - `AZURE_DEPLOYMENT_NAME` - Model deployment name (defaults to 'gpt-4')
  - `AZURE_MODEL_NAME` - Optional model name override

### AI Architecture ‚úÖ OPTIMIZED
- **Client Setup**: [src/lib/ai.ts](mdc:src/lib/ai.ts) - Single `AzureOpenAI` client instance
- **Prompt Management**: [src/lib/prompts/index.ts](mdc:src/lib/prompts/index.ts) - Centralized prompt templates with GPT-5 best practices
- **JSON Response Format**: All AI functions use `response_format: { type: 'json_object' }` with explicit JSON instructions
- **Performance Config**: `reasoning_effort: 'low'` for optimized speed vs. quality balance
- **Model**: GPT-5 (or gpt-5-nano) via Azure OpenAI deployment

### Auto-Coaching Workflow ‚úÖ OPTIMIZED (Single AI Call)
1. **Step 1: Always Fetch Context** - Get conversation history for better analysis
   - Fetch last 15 messages from Slack API for all messages
   - Provides context for more accurate analysis

2. **Step 2: Comprehensive Analysis** - Single AI call handles everything
   - Uses `comprehensiveMessageAnalysis()` - one AI call replaces 4 separate calls
   - Performs screening, detailed analysis, target identification, and message improvement
   - **75% faster** and **75% cheaper** than previous multi-call approach

3. **Step 3: Send Coaching** - Only if issues found
   - Ephemeral feedback with improved message suggestions
   - Interactive buttons for message replacement

### AI Functions Implemented
**Auto-Coaching (Optimized):**
- **`comprehensiveMessageAnalysis()`** - Single AI call for complete analysis (NEW)

**Manual Commands (Preserved):**
- **`analyzeMessageForFlags()`** - Detailed analysis with context (for `/personalfeedback`)
- **`analyzeMessageForRephraseWithoutContext()`** - Context-free analysis for `/rephrase`
- **`analyzeMessageForRephraseWithContext()`** - Context-aware analysis for `/rephrase`
- **`generateImprovedMessage()`** - Basic message improvements for `/rephrase`
- **`generateImprovedMessageWithContext()`** - Context-aware improvements for `/rephrase`
- **`generatePersonalFeedback()`** - User communication patterns analysis
- **`generateReport()`** - Weekly/monthly communication reports

**Legacy Functions (Removed):**
- ~~`quickCheckNeedsCoaching()`~~ - Replaced by comprehensive analysis
- ~~`identifyMessageTarget()`~~ - Integrated into comprehensive analysis

### Prompt Design Principles ‚úÖ UPDATED (GPT-5 Best Practices)
- **Conservative by default** - Don't flag normal professional communication
- **Explicit JSON format** - Required for Azure OpenAI `json_object` mode
- **Context separation** - Clear distinction between current message and history
- **Specific examples** - Concrete examples of what to flag/not flag
- **Tone adaptation** - Match user's tone, register, and formality in improvements
- **Human-like output** - Avoid AI-ish phrasing, hedging, or generic filler
- **Slack-specific preservation** - Keep @mentions, <#channel> references, links, code
- **Natural length** - Keep approximately same length unless brevity obviously helps

### Contextual Analysis Patterns ‚úÖ NEW
- **Conditional Context Usage**: `/rephrase` command intelligently uses conversation history when bot has channel access
- **Channel Access Detection**: Uses `isChannelAccessible()` to determine if bot can fetch conversation history
- **Dual Analysis Paths**:
  - **With Context**: `analyzeMessageForRephraseWithContext()` - Uses last 10 messages for better understanding
  - **Without Context**: `analyzeMessageForRephraseWithoutContext()` - Analyzes only the provided message text
- **Context-Aware Improvements**: `generateImprovedMessageWithContext()` creates suggestions that fit conversation flow
- **Privacy-First**: Only accesses conversation data when bot is explicitly added to channels

## Slack Slash Command Modal Responses
- When a slash command opens a modal via `views.open`, **never** wait for the API call to resolve before responding to Slack.
- Respond with an **empty 200 OK** (no JSON body) or `null` in Next.js API routes to acknowledge the request immediately.
- This prevents Slack from posting a `Slackbot` operation_timeout error or showing "We had some trouble connecting" banners.
- Handle any async work (e.g., DB updates, secondary API calls) in the background and log errors instead of blocking the response.

## Using `after()` for background tasks (Next.js 15)
- When running on Vercel, prefer Next.js `after()` from `next/server` to schedule any asynchronous work (DB writes, external API calls, logging) **after** the HTTP response has been sent.
- Pattern:
  ```ts
  import { after } from 'next/server';

  // inside route handler
  after(async () => {
    await doLongTask();
  });

  return new Response(null, { status: 200 });
  ```
- This guarantees the work completes (or errors) without risking Slack‚Äôs 3-second timeout and without dropping promises when the serverless invocation ends.
- Continue to respond to Slack immediately (empty 200 or minimal JSON) before the 3-second window.

## Enhanced Rephrase Command Implementation ‚úÖ COMPLETED

### Contextual Analysis Workflow
The `/rephrase` command now intelligently adapts based on bot channel permissions:

**Implementation Pattern:**
```typescript
// Check if bot has channel access
const hasChannelAccess = await isChannelAccessible(channelId, user.workspaceId);

if (hasChannelAccess) {
    // Fetch last 10 messages for context
    const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 10);
    // Use context-aware analysis
    const analysisResult = await analyzeMessageForRephraseWithContext(text, conversationHistory);
    // Generate context-aware improvements
    const improvedMessage = await generateImprovedMessageWithContext(text, primaryFlag.type, conversationHistory);
} else {
    // Analyze without context
    const analysisResult = await analyzeMessageForRephraseWithoutContext(text);
    // Generate basic improvements
    const improvedMessage = await generateImprovedMessage(text, primaryFlag.type);
}
```

### Key Features ‚úÖ IMPLEMENTED
- **Conditional Context Fetching**: Only fetches conversation history when bot is channel member
- **Timeout Prevention**: Uses `after()` for background AI processing, responds immediately
- **Ephemeral Results**: Shows suggestions as private ephemeral messages in same channel
- **Clean Interface**: Simple format with original, improved, and tone information
- **Privacy-First**: Conversation history only accessed when explicitly authorized

### User Experience
1. User runs `/rephrase Can you get this done ASAP?`
2. Immediate response: "‚è≥ Analyzing and rephrasing your message..."
3. Background analysis completes (context-aware if bot in channel)
4. Ephemeral result shows improved message with tone information

## User Settings & Preferences ‚úÖ UPDATED (Explicit Channel Enabling)

### Settings Command Implementation
- **Command**: `/settings` - Opens modal for user preference management
- **Modal Interface**: Clean, unified settings modal with three main sections
- **Settings Available**:
  - **Report Frequency**: Weekly or Monthly (radio buttons)
  - **Auto Coaching Channels**: Per-channel checkboxes for auto-coaching control
  - **Billing & Subscription**: Upgrade/manage billing integration

### Settings Modal Design ‚úÖ SIMPLIFIED LOGIC
- **Channel List**: Shows all channels where bot is active with checkboxes
- **Direct Logic**: Checked channels = auto-coaching enabled for that channel
- **Default Disabled**: No channels enabled by default (empty enabled array)
- **Optional Field**: Checkboxes are not required - users can enable specific channels
- **Dynamic Content**: Channel list fetched from `botChannelsCollection`

### Settings Persistence ‚úÖ UPDATED SCHEMA
- **Database Field**: `autoCoachingEnabledChannels: string[]` in SlackUser schema (default: empty array)
- **Direct Logic**: Empty array = coaching disabled everywhere, populated array = specific channels enabled
- **Immediate Update**: Settings saved in background using `after()` for fast response
- **Success Feedback**: Modal updates to show "‚úÖ Settings updated" message
- **Modal Behavior**: Stays open after save, user closes manually

### Per-Channel Auto Coaching Control ‚úÖ EXPLICIT OPT-IN ARCHITECTURE
- **Granular Control**: Users must explicitly enable auto-coaching for specific channels
- **Event Processing**: Only analyze if `user.autoCoachingEnabledChannels.includes(channelId)`
- **Default Behavior**: Auto-coaching disabled by default in ALL channels (safer default)
- **Manual Override**: `/rephrase` command always works regardless of auto settings
- **Multi-User Support**: Each user controls their own per-channel preferences independently

### Implementation Files
- **Settings Modal**: [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts) - `/settings` command handler
- **Settings Handler**: [src/app/api/slack/interactive/route.ts](mdc:src/app/api/slack/interactive/route.ts) - Modal submission processing
- **Auto Coaching Check**: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts) - Preference validation
- **User Creation**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts) - OAuth with default settings

## Channel Monitoring Notifications ‚úÖ ENHANCED FEATURE

### Notification System Implementation
- **Onboarding Trigger**: Sent after successful onboarding completion when channels are enabled
- **Manual Addition Trigger**: Sent when bot is manually added to channels via `member_joined_channel` event
- **Function**: `sendChannelMonitoringNotification()` in [src/lib/slack.ts](mdc:src/lib/slack.ts)
- **Integration**: 
  - Called from `completeSlackOnboarding()` in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts)
  - Called from `handleBotJoinedChannel()` in [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts)
- **Format**: Professional Block Kit DM with enabled channel list and usage instructions

### Notification Content ‚úÖ USER-FRIENDLY
- **Header**: "Clarity is now monitoring your communication in:"
- **Channel List**: Bulleted list of channels with `‚Ä¢ #channel-name` format
- **Usage Instructions**: How auto-coaching works (ephemeral messages, privacy, settings)
- **Call to Action**: "Ready to get started? Just start chatting in the enabled channels!"
- **Settings Reference**: Instructions to use `/clarity-settings` to modify channel preferences

### Implementation Patterns

#### Onboarding Completion
```typescript
// After successful onboarding and channel enabling
if (selectedChannels && selectedChannels.length > 0) {
    const workspace = await workspaceCollection.findOne({ 
        _id: new ObjectId(userWorkspaceId) 
    });
    
    if (workspace?.botToken) {
        await sendChannelMonitoringNotification(user, workspace.botToken, selectedChannels);
        console.log(`‚úÖ Sent channel monitoring notification to user ${slackId}`);
    }
}
```

#### Manual Channel Addition
```typescript
// In handleBotJoinedChannel event handler
if (!existingChannel) {
    await botChannelsCollection.insertOne({
        _id: new ObjectId(),
        workspaceId: workspace._id.toString(),
        channelId,
        channelName,
        addedAt: new Date()
    });
    
    // Send notification to workspace users about the new channel monitoring
    await notifyUsersAboutNewChannelMonitoring(workspace, channelId, channelName);
}
```

### Event-Driven Manual Addition ‚úÖ NEW
- **Trigger Event**: `member_joined_channel` when bot joins a channel
- **User Scope**: Notifies all active workspace users who have completed onboarding
- **Channel Data**: Single channel passed as array `[{ id: channelId, name: channelName }]`
- **Reuses Function**: Same `sendChannelMonitoringNotification()` for consistency

### Benefits
- **Complete Coverage**: Notifications for both onboarding and manual additions
- **User Awareness**: Users know exactly which channels are being monitored
- **Privacy Transparency**: Clear explanation that suggestions are private (ephemeral)
- **Settings Discovery**: Users learn about `/clarity-settings` command for future changes
- **Consistent Experience**: Same notification format regardless of how bot was added

## Slack Integration Best Practices ‚úÖ CRITICAL UPDATES

### Workspace-Specific Token Usage Pattern ‚úÖ MANDATORY
**Never use global bot tokens - always use workspace-specific tokens from database:**

```typescript
// ‚ùå WRONG - Global token causes auth errors
const conversationHistory = await fetchConversationHistory(channelId, process.env.SLACK_BOT_TOKEN!, undefined, 40);

// ‚úÖ CORRECT - Workspace-specific token
const user = await slackUserCollection.findOne({ slackId: userId, isActive: true });
const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 40);
```

**Why this matters:**
- Each workspace has its own bot token from OAuth installation
- Global tokens cause `invalid_auth` errors in multi-workspace environments  
- Workspace-specific tokens ensure proper permissions and isolation

### Slack Message Architecture ‚úÖ UPDATED
**All Slack messaging functions must be in [src/lib/slack.ts](mdc:src/lib/slack.ts) using Block Kit format:**

```typescript
// ‚úÖ CORRECT - Slack functions in slack.ts with Block Kit
export const sendProSubscriptionNotification = async (
    user: SlackUser,
    botToken: string
): Promise<boolean> => {
    const blocks = [
        {
            type: "section",
            text: {
                type: "mrkdwn",
                text: `üéâ *Welcome to Clarity ${proTier.name}!*`
            }
        }
        // ... more blocks
    ];
    
    return await sendDirectMessage(user.slackId, '', botToken, blocks);
};

// ‚ùå WRONG - Don't put Slack messaging logic in webhook handlers
async function sendNotification(user) {
    const message = `Welcome message...`;
    await sendDirectMessage(user.slackId, message, botToken);
}
```

**Rules:**
- **Block Kit format**: Use structured blocks like `sendWelcomeMessage` example
- **Dynamic content**: Always use data from [src/types/index.ts](mdc:src/types/index.ts) `SUBSCRIPTION_TIERS`
- **No hardcoded content**: Features, pricing, limits must come from types
- **Proper text rendering**: Use normal apostrophes `'` not HTML entities `&apos;`

### Slack Markdown Formatting ‚úÖ CRITICAL
**Use Slack's mrkdwn format, not standard Markdown:**

```typescript
// ‚ùå WRONG - HTML entities don't render properly in Slack
const message = `You&apos;re now upgraded to Pro`;

// ‚úÖ CORRECT - Use normal apostrophes and Slack mrkdwn format
const message = `*Personal Communication Feedback*\n*Overall Score*: 8/10\n_You're now upgraded to Pro._`;
```

**Slack formatting rules:**
- **Bold**: Use `*text*` (single asterisks)
- **Italic**: Use `_text_` (underscores)  
- **Code**: Use backticks `` `code` ``
- **Channels**: Use `<#channelId>` for channel references
- **Users**: Use `<@userId>` for user mentions
- **Apostrophes**: Use normal `'` not HTML entities

### Human-Only Message Filtering ‚úÖ IMPLEMENTED
**Enhanced conversation history filtering to only include human messages:**

```typescript
// In fetchConversationHistory - comprehensive filtering
const messages = result.messages
  .filter(msg => {
    // Must have text content
    if (!msg.text || msg.text.trim() === '') return false;
    
    // Filter out all bot messages
    if (msg.bot_id || msg.app_id) return false;
    
    // Filter out system messages by subtype
    if (msg.subtype && [
      'bot_message', 'channel_join', 'channel_leave', 'channel_topic',
      'channel_purpose', 'file_share', 'slackbot_response'
    ].includes(msg.subtype)) return false;
    
    // Must have a human user ID (starts with 'U')
    if (!msg.user || !msg.user.startsWith('U')) return false;
    
    // Filter out slash commands and standalone mentions
    const text = msg.text.trim();
    if (text.startsWith('/') || text.match(/^<@[UW][A-Z0-9]+>$/)) return false;
    
    return true;
  })
  .map(msg => msg.text || '')
  .reverse(); // Chronological order
```

### Background Processing with Timeout Prevention ‚úÖ IMPLEMENTED
**Slack command pattern with immediate response and background analysis:**

```typescript
// Personal feedback command example
async function handlePersonalFeedback(userId: string, channelId: string) {
  // Get user and workspace information
  const user = await slackUserCollection.findOne({ slackId: userId, isActive: true });
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  
  // Schedule background analysis using after()
  after(async () => {
    try {
      // Heavy analysis work (conversation history + AI)
      const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 40);
      const feedback = await generatePersonalFeedback(conversationHistory);
      
      // Add relationship insights
      const relationshipInsights = await analyzeRelationshipContext(conversationHistory);
      
      // Send formatted results via DM
      const formattedMessage = formatPersonalFeedbackMessage(feedback, relationshipInsights, channelId);
      await sendDirectMessage(userId, formattedMessage, workspace.botToken);
    } catch (error) {
      await sendDirectMessage(userId, 'Error generating report', workspace.botToken);
    }
  });

  // Immediately return processing message 
  return {
    text: '‚è≥ *Analyzing your communication patterns...*\n\nI\'ll send the detailed analysis to your DMs shortly!',
    response_type: 'ephemeral'
  };
}
```

### Relationship-Specific Coaching Insights ‚úÖ IMPLEMENTED
**Analyze individual messages to identify communication targets:**

```typescript
// Analyze recent messages for relationship context
let relationshipInsights: { name: string; issues: string[] }[] = [];
const relationshipMap = new Map<string, string[]>();

for (const message of recentMessages) {
  const analysis = await analyzeMessageForFlags(message, conversationHistory);
  if (analysis.flags.length > 0 && analysis.target?.name) {
    const issues = relationshipMap.get(analysis.target.name) || [];
    analysis.flags.forEach(flag => {
      if (!issues.includes(flag.type)) issues.push(flag.type);
    });
    relationshipMap.set(analysis.target.name, issues);
  }
}

// Only show if we have real person names (not "Unknown")
if (relationshipInsights.some(insight => insight.name && insight.name !== 'Unknown')) {
  feedbackMessage += `üë• *Relationship insights:*\n`;
  feedbackMessage += relationshipInsights
    .filter(insight => insight.name !== 'Unknown')
    .map(insight => `‚Ä¢ Work on *${insight.issues.join(', ')}* when messaging *${insight.name}*`)
    .join('\n');
}
```

### Friendly Coaching Tone ‚úÖ IMPLEMENTED
**Use supportive, personal language instead of formal reports:**

```typescript
// ‚ùå FORMAL - Sounds like a report
const responseText = `Communication Report\nOverall Score: 8/10\nAreas for Improvement:\n‚Ä¢ Be more specific`;

// ‚úÖ COACHING - Friendly and supportive
const responseText = `*Hey there! Here's your personal feedback*\n` +
  `*How you're doing: ${score}/10* ${score >= 8 ? 'üü¢ You\'re crushing it!' : 'üî¥ Let\'s level up together!'}\n` +
  `üí™ *Let's work on these together:*\n‚Ä¢ Be more specific in your requests`;
```

**Coaching language patterns:**
- "Hey there!" instead of formal greetings
- "How you're doing" instead of "Overall Score"  
- "Let's work on these together" instead of "Areas for Improvement"
- "Here's what I'd love to see you try next" instead of "Action Items"
- Encouraging emojis and supportive tone throughout

## Stripe Billing Portal Integration ‚úÖ IMPLEMENTED

### Settings Modal with Billing Section
The `/settings` command now includes integrated billing management:

```typescript
// Settings modal with billing section
const modal = {
  blocks: [
    // ... existing settings (frequency, auto rephrase)
    {
      type: 'divider'
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Billing & Subscription*\n${subscriptionStatusText}`
      },
      accessory: {
        type: 'button',
        text: {
          type: 'plain_text',
          text: billingButtonText,
          emoji: true
        },
        ...(isPaidUser ? {} : { style: 'primary' }),
        url: billingUrl,
        action_id: 'billing_action'
      }
    }
  ]
};
```

### Subscription Tier Configuration ‚úÖ UPDATED
**Current subscription structure in [src/types/index.ts](mdc:src/types/index.ts):**

```typescript
export const SUBSCRIPTION_TIERS = {
  FREE: {
    name: 'Free',
    price: 0,
    monthlyLimits: {
      autoCoaching: 50,        // messages per month
      manualRephrase: 50,      // messages per month  
      personalFeedback: 5,     // reports per month
    },
    features: {
      reports: true,
      advancedReportAnalytics: false
    }
  },
  PRO: {
    name: 'Pro', 
    price: 10, // $4.99/month
    monthlyLimits: {
      autoCoaching: 1000,      // messages per month
      manualRephrase: 1000,    // messages per month  
      personalFeedback: 100,   // reports per month
    },
    features: {
      reports: true,
      advancedReportAnalytics: true
    }
  }
} as const;
```

### MongoDB ObjectId Integration ‚úÖ CRITICAL
**All Stripe operations now use MongoDB `_id` instead of `slackId`:**

```typescript
// ‚úÖ CORRECT - Use MongoDB ObjectId for Stripe operations
const billingUrl = isPaidUser 
  ? `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/api/stripe/portal?user=${encodeURIComponent(user._id)}`
  : `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/api/stripe/checkout?user=${encodeURIComponent(user._id)}`;

// ‚úÖ CORRECT - Convert ObjectId to string for Stripe
const session = await createCheckoutSession(
  user._id.toString(), // Convert to string
  STRIPE_PRICE_IDS.PRO_MONTHLY,
  '', // Use Stripe default success page
  `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/app/docs` // Back button redirect
);

// ‚úÖ CORRECT - Convert string back to ObjectId for database queries
const user = await slackUserCollection.findOne({ 
  _id: new ObjectId(userId) // Convert string back to ObjectId
});
```

### Stripe Checkout Flow ‚úÖ UPDATED
**Simplified checkout with Stripe defaults:**

```typescript
// Success: Uses Stripe default success page (no custom redirect)
// Cancel/Back: Redirects to /app/docs for easy navigation
const session = await createCheckoutSession(
  userId,
  priceId,
  '', // Stripe default success page
  `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/app/docs` // Back button
);
```

### User Experience Patterns ‚úÖ IMPLEMENTED

**Settings Modal Layout:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Settings            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Report Frequency            ‚îÇ 
‚îÇ ‚óã Weekly  ‚óè Monthly         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Auto Rephrase              ‚îÇ
‚îÇ ‚òë Enable automatic rephrase ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Billing & Subscription      ‚îÇ
‚îÇ Current Plan: Pro - $4.99/mo  ‚îÇ
‚îÇ (active)                    ‚îÇ
‚îÇ         [Manage Billing] ‚Üê‚îÄ‚îÄ‚î§ Opens in new tab
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           [Save]            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Conditional Button Logic:**
- **FREE users**: Blue "Upgrade to Pro" button ‚Üí Stripe Checkout
- **PRO users**: Gray "Manage Billing" button ‚Üí Stripe Customer Portal
- **Modal persistence**: Settings modal stays open after billing button click

### Subscription Validation Patterns ‚úÖ UPDATED
**Simplified rate limiting (no unlimited `-1` values):**

```typescript
// All features now have numeric limits
const accessCheck = await validateUserAccess(userId, 'personalFeedback');
if (!accessCheck.allowed) {
  if (accessCheck.upgradeRequired) {
    return generateUpgradeMessage('personalFeedback', accessCheck.reason, accessCheck.user?._id);
  }
  return generateLimitReachedMessage('personalFeedback', currentUsage, limit, resetDate, accessCheck.user?._id);
}
```

### Error Handling Patterns ‚úÖ IMPLEMENTED
- **ObjectId Conversion**: Always use `.toString()` for Stripe operations
- **Database Queries**: Always use `new ObjectId()` for MongoDB operations  
- **Button Styling**: Use conditional styling (no `'default'` style, only `'primary'` or omit)
- **Webhook Processing**: Handle MongoDB ObjectId strings from Stripe metadata

### Subscription Notifications ‚úÖ IMPLEMENTED
**Prevent duplicate notifications and use dynamic content:**

```typescript
// ‚úÖ Prevent duplicate notifications - only send for new upgrades
const previousTier = user.subscription?.tier || 'FREE';
if (tier === 'PRO' && previousTier === 'FREE') {
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  if (workspace?.botToken) {
    await sendProSubscriptionNotification(user, workspace.botToken);
  }
}

// ‚úÖ Use dynamic content from SUBSCRIPTION_TIERS in types
const proTier = SUBSCRIPTION_TIERS.PRO;
const proFeatures = proTier.displayFeatures.filter(f => f.included);
```

**Notification Rules:**
- **Block Kit format**: All notifications use structured blocks in [src/lib/slack.ts](mdc:src/lib/slack.ts)
- **Dynamic content**: Never hardcode features, pricing, or limits - use `SUBSCRIPTION_TIERS`
- **Duplicate prevention**: Check previous tier before sending upgrade notifications
- **Proper text**: Use normal apostrophes `'` not HTML entities `&apos;`
- **Workspace tokens**: Always use workspace-specific bot tokens

## Comprehensive Logging & Error Tracking ‚úÖ IMPLEMENTED

### Logging Architecture
- **Logger Utility**: [src/lib/logger.ts](mdc:src/lib/logger.ts) - Structured logging with INFO, WARN, ERROR, DEBUG levels
- **PostHog Integration**: [src/lib/posthog.ts](mdc:src/lib/posthog.ts) - Server-side error and event tracking
- **Client Analytics**: [src/hooks/useAnalytics.ts](mdc:src/hooks/useAnalytics.ts) - Renamed to `usePostHog` for direct usage

### Mandatory Error Tracking Pattern ‚úÖ ENFORCED
**Every API route MUST have comprehensive error tracking:**

```typescript
} catch (error) {
    const errorObj = error instanceof Error ? error : new Error(String(error));
    
    // Structured logging for developers
    logError('Descriptive error message', errorObj, { 
        endpoint: '/api/route/path',
        user_id: userId,
        operation: 'specific_operation'
    });
    
    // PostHog analytics for business insights
    trackError(userId || 'anonymous', errorObj, { 
        endpoint: '/api/route/path',
        operation: 'specific_operation',
        context: 'additional_context'
    });
    
    return NextResponse.json({ error: 'User-friendly message' }, { status: 500 });
}
```

### Success Operation Logging ‚úÖ IMPLEMENTED
**Track successful operations with info logs:**

```typescript
logInfo('Operation completed successfully', { 
    user_id: userId,
    endpoint: '/api/route/path',
    operation: 'specific_operation',
    // Additional success context...
});
```

### Event Tracking Rules ‚úÖ UPDATED
- **Use centralized events**: All event names in [src/lib/analytics/events.ts](mdc:src/lib/analytics/events.ts)
- **Follow naming convention**: `category:object_action` format (e.g., `feature:auto_coaching_triggered`)
- **AUTO_COACHING_TRIGGERED**: Only fire when rephrased message is actually sent to user
- **No skipped events**: Don't track when no action is taken

### Logging Levels Usage
- **INFO**: Successful operations, user journeys, business metrics
- **WARN**: Recoverable issues, deprecation warnings
- **ERROR**: Failures, exceptions, critical issues requiring attention
- **DEBUG**: Development debugging, detailed flow tracing

### Required Imports for API Routes
```typescript
// Standard logging and analytics imports for all API routes
import { logError, logInfo } from '@/lib/logger';
import { trackEvent, trackError } from '@/lib/posthog';
import { EVENTS, ERROR_CATEGORIES } from '@/lib/analytics/events';
```

## PostHog Analytics Integration ‚úÖ IMPLEMENTED

### Frontend Analytics (Autocapture)
- **Configuration**: [instrumentation-client.ts](mdc:instrumentation-client.ts) - Full autocapture enabled
- **Coverage**: Automatic tracking of page views, clicks, form submissions, navigation, errors
- **Implementation**: NO manual tracking in frontend components - autocapture handles everything
- **Clean Code**: Frontend components focus purely on UI without analytics clutter

### Backend Analytics (Manual with Rich Metadata)
- **Event Tracking**: All API routes include `trackEvent()` with user context
- **Error Tracking**: Comprehensive error categorization with `ERROR_CATEGORIES`
- **User Metadata**: Every event includes `user_name`, `workspace_id`, `subscription_tier`
- **Business Intelligence**: Feature usage, conversion funnel, performance metrics

### User Identification Strategy
- **Simplified Identification**: Only `name`, `slack_user_id`, `mongodb_id` during OAuth
- **Single Point**: User identification only in OAuth callback, not on help pages
- **PostHog Caching**: User properties persist across sessions automatically

### Analytics Coverage Achieved
- **Complete User Journey**: Landing ‚Üí OAuth ‚Üí Onboarding ‚Üí Feature Usage
- **Feature Adoption**: Auto-coaching, manual commands, settings, subscriptions
- **Onboarding Barriers**: Track when users try to access features before completing onboarding
- **Performance Metrics**: AI analysis timing, success rates, error patterns
- **Business Intelligence**: Subscription conversion, usage patterns, user segmentation

## Onboarding Requirement Enforcement ‚úÖ IMPLEMENTED

### Feature Access Control
- **Onboarding Required**: All feature commands require `hasCompletedOnboarding: true`
- **Blocked Features**:
  - `/clarity-personal-feedback` - Personal communication analysis
  - `/clarity-rephrase` - Manual message improvement
  - `/clarity-settings` - User preferences and billing
- **Allowed Features**:
  - `/clarity-help` - Always accessible for user guidance
  - `/clarity-status` - Always accessible for channel status

### User Experience for Incomplete Onboarding
**Command Response Pattern:**
```typescript
// Immediate ephemeral response with onboarding button
{
  text: 'Please complete onboarding to access Clarity features.',
  response_type: 'ephemeral',
  blocks: [
    {
      type: 'section',
      text: { type: 'mrkdwn', text: 'Please complete onboarding to access Clarity features.' },
      accessory: {
        type: 'button',
        text: { type: 'plain_text', text: 'Complete Onboarding' },
        url: `${baseUrl}/app/onboarding?user=${userId}&team=${workspaceId}`
      }
    }
  ]
}
```

### Auto Coaching Protection
- **Event Processing**: Auto coaching events are skipped for users without completed onboarding
- **Silent Operation**: No feedback sent, no errors logged (clean user experience)
- **Database Check**: `hasCompletedOnboarding` validated before AI analysis

### PostHog Onboarding Tracking ‚úÖ IMPLEMENTED
**New Event Type:**
```typescript
// Track onboarding requirement barriers
LIMITS_ONBOARDING_REQUIRED: 'limits:onboarding_required'
```

**Event Data Structure:**
```typescript
{
  command: string,           // Feature attempted (e.g., 'auto_coaching', '/personalfeedback')
  channel_id: string,        // Slack channel where attempted
  user_name: string,         // User's display name
  workspace_id: string,      // MongoDB workspace ObjectId
  subscription_tier: string, // 'FREE' or 'PRO'
  message_length?: number    // For auto coaching events
}
```

**Tracking Implementation:**
- **Command Handlers**: Track when users try feature commands without onboarding
- **Auto Coaching**: Track when auto coaching is skipped due to incomplete onboarding
- **Business Insights**: Understand onboarding conversion barriers and feature demand

### Onboarding Prompt Function
**Location**: [src/lib/slack.ts](mdc:src/lib/slack.ts) - `sendOnboardingPromptMessage()`

```typescript
export const sendOnboardingPromptMessage = async (
    userId: string,
    teamId: string,
    botToken: string
): Promise<boolean>
```

**Features:**
- **Clean Design**: Simple, informative message without overwhelming details
- **Direct Action**: Clear "Complete Onboarding" button with proper URL
- **Background Processing**: Sent via `after()` to avoid blocking responses
- **Error Handling**: Graceful failure without breaking user flow

### Database Schema Integration
**Existing Field**: `hasCompletedOnboarding: boolean` in `SlackUserSchema`
- **Default**: `false` for new users
- **Update**: Set to `true` when onboarding completes
- **Validation**: Checked before all feature access

### Best Practices ‚úÖ ENFORCED
- **Immediate Response**: Always respond to Slack within timeout limits
- **Background Processing**: Use `after()` for non-critical operations
- **Consistent URLs**: Use `${baseUrl}/app/onboarding?user=${userId}&team=${teamId}` format
- **Clean UX**: Ephemeral messages don't interrupt channel conversation
- **Analytics Tracking**: Every access attempt is tracked for business insights

### Implementation Files
- **Command Checks**: [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts)
- **Auto Coaching Check**: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts)
- **Onboarding Prompt**: [src/lib/slack.ts](mdc:src/lib/slack.ts)
- **Event Tracking**: [src/lib/analytics/events.ts](mdc:src/lib/analytics/events.ts)

## Reports System Architecture ‚úÖ OPTIMIZED & FIXED

### Incremental Reporting Approach
**Problem Solved**: Eliminated inefficient historical data fetching that caused high database load and AI token costs.

**Solution**: 
- **Current Period Only**: Scripts fetch only messages from the current week/month (90% fewer queries)
- **Report Comparisons**: Compare current data with previous *generated reports* instead of raw historical messages
- **Pre-calculated Metadata**: Store chart-ready data directly in report schema to avoid recalculations

### Performance Gains Achieved
- **Database Queries**: ~90% reduction (only current period data)
- **AI Token Usage**: ~80% reduction (report comparisons vs raw message analysis)
- **Chart Generation**: Instant loading with pre-calculated trends
- **Memory Usage**: ~95% reduction (small datasets vs full message history)
- **Script Execution**: Proper termination prevents hanging processes

### Report Generation Scripts ‚úÖ NATIVE ENV LOADING
**Location**: [src/app/scripts/](mdc:src/app/scripts/)

**Environment Configuration**:
- **Native Node.js**: Uses Node.js 20.6.0+ native `--env-file` flag (no dotenv dependency)
- **Development**: Uses `.env.local` automatically loaded by Node.js
- **Production**: Uses `.env.production` automatically loaded by Node.js
- **Package Scripts**: Clean commands using native env loading

```bash
# Development (uses .env.local)
npm run reports:weekly:dev     # tsx --env-file=.env.local
npm run reports:monthly:dev    # tsx --env-file=.env.local  
npm run reports:all:dev        # tsx --env-file=.env.local
npm run reports:test:dev       # tsx --env-file=.env.local

# Production (uses .env.production)
npm run reports:weekly:prod    # tsx --env-file=.env.production
npm run reports:monthly:prod   # tsx --env-file=.env.production
npm run reports:all:prod       # tsx --env-file=.env.production
npm run reports:test:prod      # tsx --env-file=.env.production
```

### Critical Data Model Fixes ‚úÖ RESOLVED
- **userId Storage**: Analysis instances now store `userId: user._id` (MongoDB ObjectId) instead of Slack ID
- **Date Boundaries**: Weekly reports use proper Monday-to-Monday boundaries, monthly use 1st-of-month boundaries
- **Query Matching**: Report scripts query with ObjectId directly for perfect data matching
- **Type Safety**: Updated `AnalysisInstanceSchema` to expect `ObjectId` for `userId` field

### Data Storage Strategy ‚úÖ PRIVACY-FIRST
**Analysis Instances**: Only store flagged parameters, timestamps, and AI metadata - never exact message content.

### Target Resolution Architecture ‚úÖ IMPLEMENTED
**Dynamic user name resolution for better accuracy and performance:**

#### Storage Pattern
- **Store IDs, not names**: Save `targetIds: string[]` array with Slack user IDs
- **Multiple targets**: Support messages directed to multiple people
- **No real-time resolution**: Avoid API calls during message analysis for better performance

#### Resolution Pattern  
- **Dynamic resolution**: Resolve user names during report generation using workspace bot token
- **Bulk resolution**: Collect all unique target IDs and resolve in parallel batches
- **Fresh data**: Always use current display names from Slack workspace
- **Error handling**: Graceful fallbacks when users can't be resolved

#### Implementation Functions
```typescript
// Single user resolution
const userName = await resolveSlackUserName(userId, workspace.botToken);

// Bulk user resolution (preferred for reports)
const resolvedNames = await resolveSlackUserNames(userIds, workspace.botToken);
// Returns: Record<string, string> mapping userId -> displayName
```

#### AI Prompt Enhancement
- **Extract user IDs**: AI identifies Slack user IDs from @mentions and context
- **Multiple targets**: Returns `targetIds: string[]` instead of single target object
- **Improved accuracy**: Focus on reliable ID extraction over name guessing

```typescript
// What gets stored from auto-coaching ‚úÖ UPDATED TARGET RESOLUTION
AnalysisInstance {
  _id: ObjectId,
  userId: string,
  workspaceId: string,
  channelId: string,
  messageTs: string,
  flagIds: number[], // Array of flag IDs from MESSAGE_ANALYSIS_TYPES
  targetIds: string[], // üéØ Multiple target Slack user IDs (e.g., ["U123456789", "U987654321"])
  createdAt: Date,
  aiMetadata: {
    primaryFlagId: number,
    confidence: number,
    reasoning: string,
    suggestedTone?: string
  }
}
```

### Report Schema with Optimization ‚úÖ NEW
**Pre-calculated data structure eliminates repeated computations:**

```typescript
Report {
  _id: string,
  reportId: string, // Long unguessable ID for security
  userId: string,
  period: 'weekly' | 'monthly',
  
  // Current period data only (not historical)
  currentPeriod: {
    totalMessages: number,
    flaggedMessages: number,
    flaggedMessageIds: string[], // For Slack deep links
    flagBreakdown: FlagBreakdown[], // With message IDs for examples
    partnerAnalysis: PartnerAnalysis[], // Current relationships only
  },
  
  // Pre-calculated chart data (no recalculation needed)
  chartMetadata: {
    flagTrends: Array<{flagId: number, current: number, previous: number}>,
    scoreHistory: Array<{period: string, score: number}>,
    partnerTrends: Array<{partner: string, improvement: number}>,
  },
  
  // Calculated scores and insights
  communicationScore: number,
  scoreChange: number,
  recommendations: string[],
  achievements: string[],
  
  createdAt: Date,
  expiresAt: Date // Optional expiration for cleanup
}
```

### Report Delivery Integration ‚úÖ SLACK DM
**Interactive Slack messages with webpage links:**

- **Compact Format**: Communication score, top issues, key insights
- **Interactive Buttons**: "View Full Report" redirects to `/reports/weekly/{id}` or `/reports/monthly/{id}`
- **Security**: Long unguessable IDs eliminate need for authentication
- **Block Kit Format**: Professional formatting with proper emojis and layout

### Report Webpages ‚úÖ ANALYTICS FOCUSED
**Detailed report views with visual analytics:**

- **Routes**: `/reports/weekly/[id]` and `/reports/monthly/[id]`
- **Components**: [src/components/reports/WeeklyReportView.tsx](mdc:src/components/reports/WeeklyReportView.tsx) and [src/components/reports/MonthlyReportView.tsx](mdc:src/components/reports/MonthlyReportView.tsx)
- **Charts**: Line graphs showing flag trends (current vs previous period)
- **Message Examples**: Deep links to original Slack messages
- **Partner Analysis**: Communication improvement recommendations by person

### Script Termination Best Practices ‚úÖ IMPLEMENTED
**All scripts properly terminate to prevent hanging:**

```typescript
// Pattern used in all report generation scripts
console.log('üéâ Report generation completed');

// Close database connection when running directly
if (require.main === module) {
    process.exit(0);
}

// Error handling with proper exit codes
generateReports().catch((error) => {
    console.error('‚ùå Report generation failed:', error);
    process.exit(1);
});
```

### Implementation Files Updated ‚úÖ COMPLETE
- **Types**: [src/types/index.ts](mdc:src/types/index.ts) - `AnalysisInstanceSchema` and `ReportSchema`
- **Database**: [src/lib/db.ts](mdc:src/lib/db.ts) - Added `reportCollection`
- **Auto-coaching**: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts) - Stores `flagIds` array
- **Report Utils**: [src/lib/report-utils.ts](mdc:src/lib/report-utils.ts) - Optimized calculation functions
- **Slack Integration**: [src/lib/slack.ts](mdc:src/lib/slack.ts) - Report DM functions
- **Scripts**: All generation and test scripts with proper termination
- **Components**: Report viewing components with chart integration
- **Package**: [package.json](mdc:package.json) - Environment-specific script commands

---
_Use this snapshot alongside the guidelines above to maintain consistency and avoid duplicating functionality._