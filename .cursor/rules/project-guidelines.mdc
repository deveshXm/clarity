---
alwaysApply: true
---

# Your role
You are an award winning app designer & developer. Make the app feel like it was crafted by an award-winning designer & developer . Ultra-modern, playful, highly usable, with smooth microinteractions and delightful UX touches that elevate the entire experience.

When you write code, ensure it is clean, minimal, and easy to read. Avoid unnecessary functions or complexity. Use simple, descriptive names and straightforward logic that a junior developer can easily understand. Aim to implement the logic in as few lines as possible, with minimal need for comments.

# Project Guidelines

## App Identity & Naming
- **App Name**: Generic boilerplate - use "Your App" or similar generic names
- **Database Naming**: Use environment variable `MONGODB_DB_NAME` for database name
- **Consistency**: Keep branding generic and customizable
- **Case Usage**: 
  - UI/Display: Generic names like "Your App" (capitalized)
  - Database/Technical: Use environment variables
  - File names: Follow existing conventions (kebab-case, camelCase as appropriate)

## File Organization
- **Minimize file creation**: Do not create unnecessary files
- **Single file approach**: Keep related functionality in single files where it makes sense
- **Consolidate similar code**: Use index files to group related exports
- **Examples**:
  - All types in [src/types/index.ts](mdc:src/types/index.ts)
  - All hooks in [src/hooks/index.ts](mdc:src/hooks/index.ts)
  - All context providers in [src/context/index.tsx](mdc:src/context/index.tsx)

## Component Organization
- **Common components only**: Only keep components in [src/components/](mdc:src/components) that are common or can be used by multiple different pages
- **Page-specific components**: Keep components that are specific to a particular page in the same folder as the page in the app directory for easy accessibility and clarity
- **Co-location principle**: Components used by only one page should live next to that page, not in the global components folder

## Development Approach
- **Only do what's requested**: Do not add extra features or functionality unless explicitly asked
- **Ask for permission**: If you want to add something extra, always ask for permission first
- **Follow up questions**: If confused about requirements, ask clarifying questions
- **Stay focused**: Complete the specific task requested before suggesting improvements

## Build Quality & Error Prevention
- **JSX Entity Escaping**: Always escape special characters in JSX text content to prevent React unescaped entity errors
  - Use `&apos;` for apostrophes: `you'll` ‚Üí `you&apos;ll`
  - Use `&ldquo;` and `&rdquo;` for quotes: `"quoted text"` ‚Üí `&ldquo;quoted text&rdquo;`
  - Use `&amp;` for ampersands: `A & B` ‚Üí `A &amp; B`
- **TypeScript Parameter Usage**: Remove unused parameters from function signatures instead of prefixing with underscore
  - ‚ùå WRONG: `function handleData(_unusedParam: string, data: string)`
  - ‚úÖ CORRECT: `function handleData(data: string)` and update all calls
- **Type Safety**: Never use `any` type - always provide explicit type annotations
  - ‚ùå WRONG: `const params: any = { channel: id };`
  - ‚úÖ CORRECT: `const params: { channel: string; limit?: number } = { channel: id };`
- **Suspense Boundaries**: Wrap components using `useSearchParams()` or other client-side hooks in Suspense boundaries
  - Always wrap in `<Suspense fallback={LoadingComponent}>` when using `useSearchParams()`, `useRouter()` with client-side navigation
  - Provide meaningful loading fallbacks for better UX
- **ESLint Compliance**: Follow all ESLint rules without exceptions - fix issues rather than disable rules
- **Build Verification**: Always run `npm run build` before completing tasks to ensure no build errors
- **Import Optimization**: All API routes have been refactored to use static imports for better performance and type safety

## Framework-First Approach
- **Next.js 15** - we are using nextjs 15 version
- **Use Next.js built-ins**: Always use Next.js default features like `loading.tsx`, `error.tsx`, and `not-found.tsx` for handling loading states, errors, and 404s instead of custom logic
- **Check before creating**: Always check if a component, hook, or utility already exists in the framework or codebase before creating a new one
- **Ask before building**: Must ask permission before creating new components, utilities, or logic that might already exist in the framework
- **Leverage defaults**: Prefer Next.js conventions (file-based routing, built-in components) over custom implementations

## Code Duplication Prevention
- **Check before creating**: Always search existing codebase before creating new functions, types, or database operations
- **Search locations**:
  - Functions: Check [src/lib/](mdc:src/lib), [src/hooks/index.ts](mdc:src/hooks/index.ts), and relevant component files
  - Types: Check [src/types/index.ts](mdc:src/types/index.ts) first
  - Database operations: Check [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) first
- **Reuse over recreation**: If similar functionality exists, extend or modify rather than duplicate

## Import Management & Performance ‚úÖ IMPLEMENTED
- **Static imports only**: NEVER use dynamic imports (`await import()` or `require()`) in API routes
- **Top-level imports**: All imports must be declared at the top of the file for optimal performance
- **Build-time optimization**: Static imports enable better tree-shaking and bundle optimization
- **Common import patterns**:
  ```typescript
  // ‚úÖ CORRECT - Static imports at top
  import { NextRequest, NextResponse } from 'next/server';
  import { ObjectId } from 'mongodb';
  import { workspaceCollection } from '@/lib/db';
  import { WebClient } from '@slack/web-api';
  
  export async function POST(request: NextRequest) {
    // Use imports directly without dynamic loading
    const workspace = await workspaceCollection.findOne({ _id: new ObjectId(id) });
    const slack = new WebClient(token);
  }
  
  // ‚ùå WRONG - Dynamic imports (performance penalty)
  export async function POST(request: NextRequest) {
    const { ObjectId } = await import('mongodb');
    const { workspaceCollection } = await import('@/lib/db');
  }
  ```
- **Type safety benefits**: Static imports provide better TypeScript inference and error checking
- **Consistency**: All API routes in [src/app/api/](mdc:src/app/api) follow this pattern

## UI Component Architecture
- **Mantine as base**: Always use Mantine library components as the foundation
- **Wrapper pattern**: Create wrapper components in [src/components/ui/](mdc:src/components/ui) to prevent vendor lock-in
- **NEVER use Mantine directly**: NEVER import or use Mantine components directly in any application code. ALL Mantine components must be wrapped in UI components first
- **UI components only**: Always import components from `@/components/ui` - never from `@mantine/core` or any other UI library
- **NO RAW DIVS**: Never use raw `<div>` elements - always use appropriate Mantine wrapper components like `Stack`, `Row`, `Center`, `Card`, etc.
- **Forward refs**: Always use `forwardRef` for UI components to maintain ref compatibility
- **Export pattern**: Export wrapped components from [src/components/ui/index.ts](mdc:src/components/ui/index.ts)
- **Next.js components**: Wrap Next.js components (Link, Image, etc.) with custom components using `forwardRef` to maintain fixed values and consistency
- **Layout Components**: Use semantic Mantine components for all layout needs:
  - `<Stack>` for vertical layouts
  - `<Row>` (Group wrapper) for horizontal layouts  
  - `<Center>` for centering content
  - `<Container>` for page-level containers
- **Example structures**:
  ```typescript
  // ‚ùå WRONG - Never do this
  import { Button, Text, Stack } from '@mantine/core';
  
  // ‚ùå WRONG - Never use raw divs
  <div style={{ display: 'flex', justifyContent: 'center' }}>
    <div style={{ padding: 20 }}>Content</div>
  </div>
  
  // ‚úÖ CORRECT - Always do this
  import { Button, Text, Stack, Row, Center } from '@/components/ui';
  
  <Row justify="center">
    <Stack p={20}>Content</Stack>
  </Row>
  ```

## Mantine UI Setup

### Configuration Files
- **Theme Configuration**: [src/lib/theme.ts](mdc:src/lib/theme.ts) - Professional color palette with primary blue, secondary teal, accent orange, and status colors
- **PostCSS Setup**: [postcss.config.cjs](mdc:postcss.config.cjs) - Mantine preset and responsive breakpoint variables
- **Layout Integration**: [src/app/layout.tsx](mdc:src/app/layout.tsx) - MantineProvider, ColorSchemeScript, and theme application
- **Next.js Optimization**: [next.config.ts](mdc:next.config.ts) - Package import optimization for Mantine components

### Usage
- Always use theme colors from [src/lib/theme.ts](mdc:src/lib/theme.ts) instead of arbitrary colors
- Components are pre-configured with professional defaults (radius, shadows, sizes)
- Follow UI component architecture rules for creating wrapper components

## UI Components Inventory

### Core UI Components
- **Button** - [src/components/ui/Button.tsx](mdc:src/components/ui/Button.tsx) - Basic button wrapper with forwardRef
- **LoadingButton** - [src/components/ui/LoadingButton.tsx](mdc:src/components/ui/LoadingButton.tsx) - Button with built-in loading states and Lucide icons
- **TextInput** - [src/components/ui/TextInput.tsx](mdc:src/components/ui/TextInput.tsx) - Text input wrapper
- **Textarea** - [src/components/ui/Textarea.tsx](mdc:src/components/ui/Textarea.tsx) - Textarea wrapper
- **Card** - [src/components/ui/Card.tsx](mdc:src/components/ui/Card.tsx) - Card wrapper
- **AnimatedCard** - [src/components/ui/AnimatedCard.tsx](mdc:src/components/ui/AnimatedCard.tsx) - Card with hover and click animations
- **LoadingOverlay** - [src/components/ui/LoadingOverlay.tsx](mdc:src/components/ui/LoadingOverlay.tsx) - Loading overlay wrapper

### Layout Components
- **Container** - [src/components/ui/Container.tsx](mdc:src/components/ui/Container.tsx) - Container wrapper
- **Stack** - [src/components/ui/Stack.tsx](mdc:src/components/ui/Stack.tsx) - Stack layout wrapper
- **Center** - [src/components/ui/Center.tsx](mdc:src/components/ui/Center.tsx) - Center alignment wrapper

### Typography Components
- **Title** - [src/components/ui/Title.tsx](mdc:src/components/ui/Title.tsx) - Title/heading wrapper
- **Text** - [src/components/ui/Text.tsx](mdc:src/components/ui/Text.tsx) - Text wrapper

### Navigation Components
- **Link** - [src/components/ui/Link.tsx](mdc:src/components/ui/Link.tsx) - Next.js Link wrapper with fixed prefetch=false

### Form Components
- **FormField** - [src/components/ui/FormField.tsx](mdc:src/components/ui/FormField.tsx) - Reusable form field with label, description, and error handling
- **ErrorMessage** - [src/components/ui/ErrorMessage.tsx](mdc:src/components/ui/ErrorMessage.tsx) - Error alert with Lucide AlertCircle icon
- **SuccessMessage** - [src/components/ui/SuccessMessage.tsx](mdc:src/components/ui/SuccessMessage.tsx) - Success alert with Lucide CheckCircle icon

### Loading Components
- **Skeleton** - [src/components/ui/Skeleton.tsx](mdc:src/components/ui/Skeleton.tsx) - Basic skeleton wrapper
- **FormSkeleton** - [src/components/ui/FormSkeleton.tsx](mdc:src/components/ui/FormSkeleton.tsx) - Specialized skeleton for forms with configurable fields

### Animation Components
- **FadeIn** - [src/components/ui/FadeIn.tsx](mdc:src/components/ui/FadeIn.tsx) - Smooth fade-in animation with customizable delay and duration
- **AnimatedCard** - Already listed above in Core UI Components

### Component Export Index
- **All components exported from**: [src/components/ui/index.ts](mdc:src/components/ui/index.ts)

### Usage Guidelines for UI Components
- **Import pattern**: Always import from the index file: `import { Button, TextInput } from '@/components/ui';`
- **Lucide icons**: All icon components use Lucide React icons (pre-installed)
- **ForwardRef compatibility**: All components support ref forwarding
- **TypeScript types**: All components export proper TypeScript interfaces/types
- **Mantine foundation**: All components wrap Mantine components to prevent vendor lock-in

## Color Scheme Management
- **Use predefined colors only**: Never use random or hardcoded colors
- **Color source**: All colors must come from the established color scheme configuration
- **Configuration location**: Colors defined in theme/config files (to be determined)
- **No arbitrary colors**: Avoid using arbitrary Tailwind colors or CSS color values
- **Consistency**: Maintain visual consistency across all components and pages

## Subscription System & Pricing Management ‚úÖ CENTRALIZED
- **Single Source of Truth**: All subscription data managed in [src/types/index.ts](mdc:src/types/index.ts) `SUBSCRIPTION_TIERS` object
- **No Hardcoded Features**: Never hardcode pricing, features, or descriptions in UI components
- **Dynamic UI Content**: All pricing cards, feature lists, and descriptions pull from `SUBSCRIPTION_TIERS`
- **Easy Updates**: Change pricing, features, or descriptions in one place to update everywhere
- **Consistent Display**: Both onboarding and landing page use identical subscription data
- **Feature Structure**: Each tier includes:
  ```typescript
  {
    name: 'Free',
    price: 0,
    description: 'Quick start with core coaching.',
    priceLabel: '/ forever',
    displayFeatures: [
      {
        name: 'Feature name',
        description: 'Feature description',
        included: true,
        limit?: 50,
        limitLabel: 'Display text'
      }
    ]
  }
  ```
- **Usage Pattern**: Always import and use `SUBSCRIPTION_TIERS` from types:
  ```typescript
  import { SUBSCRIPTION_TIERS } from '@/types';
  
  // ‚úÖ CORRECT - Dynamic content
  <Text>{SUBSCRIPTION_TIERS.FREE.description}</Text>
  {SUBSCRIPTION_TIERS.FREE.displayFeatures.map(feature => (
    <Text key={feature.name}>{feature.limitLabel}</Text>
  ))}
  
  // ‚ùå WRONG - Hardcoded content
  <Text>Quick start with core coaching.</Text>
  <Text>50 auto coaching/month</Text>
  ```

## Database Architecture
- **Use Native MongoDB Driver**: The project uses MongoDB's native Node.js driver (not Mongoose)
- **Database Connection**: MongoDB client is configured in [src/lib/db.ts](mdc:src/lib/db.ts)
- **Database Name**: Use `process.env.MONGODB_DB_NAME` for database name
- **No ODM/ORM**: Direct MongoDB operations without abstraction layer
- **Server Actions**: All database operations should be in Server Actions in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts)
- **Collection Operations**: Use native MongoDB collection methods (insertOne, findOne, updateOne, etc.)

## Authentication & Slack Integration Architecture
- **Slack OAuth**: Direct Slack app installation without traditional web authentication
- **Workspace-Specific Tokens**: Each workspace has its own bot token stored during OAuth installation
- **Bot Token Storage**: Workspace-specific `botToken` field in workspaceCollection enables per-workspace API calls
- **Channel Access Control**: Bot only operates in channels explicitly selected during onboarding
- **Authorization Strategy**: Simple database presence check - if user exists in database, they're authorized
- **Authentication Flow**:
  1. **Website Install**: User clicks "Install to Slack" ‚Üí OAuth ‚Üí Database entry ‚Üí Full access
  2. **Direct Install**: User installs from Slack App Directory ‚Üí OAuth ‚Üí Database entry ‚Üí Full access
  3. **Command Authorization**: If user NOT in database ‚Üí Show authorization message with website redirect
- **Token Usage**: All Slack API calls use workspace-specific tokens from database
- **No Web Sessions**: Standard Slack app approach - all data tied to Slack user IDs

## Slack Event Handling & Auto Coaching ‚úÖ IMPLEMENTED

### Event Subscription Strategy
- **Privacy by Design**: Bot only receives events from channels where it's explicitly added as a member
- **Event Types Required**: 
  - `message.channels` - Public channel messages (REQUIRED for auto coaching)  
  - `message.groups` - Private channel messages
  - `app_mention` - @bot mentions
- **Channel Filtering**: Slack automatically filters events to only channels where bot is member
- **Database Verification**: Additional check against `botChannelsCollection` for authorized channels

### Auto Coaching Implementation ‚úÖ WORKING
- **Real-time Analysis**: Message events trigger AI analysis for communication improvement
- **Ephemeral Feedback**: Private suggestions only visible to message sender
- **Interactive Components**: "Replace Message" and "Keep Original" buttons
- **Workspace-Specific Tokens**: Each workspace uses its own bot token for API calls
- **Channel Access Control**: Double-layer verification (Slack + database) ensures privacy

### Message Event Processing Flow
```typescript
// 1. Slack sends event (only from member channels)
if (event.type === 'message' && (event.channel_type === 'channel' || event.channel_type === 'group')) {
  
  // 2. Validate user has app installed
  const user = await slackUserCollection.findOne({ slackId: event.user, isActive: true });
  if (!user) return; // Skip - user hasn't installed app
  
  // 3. Verify bot is active in specific channel  
  const isChannelActive = await isChannelAccessible(event.channel, user.workspaceId);
  if (!isChannelActive) return; // Skip - not authorized channel
  
  // 4. Get workspace-specific bot token
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  if (!workspace?.botToken) return; // Skip - missing token
  
  // 5. AI analysis and ephemeral coaching feedback
  // 6. Interactive message replacement functionality
}
```

## Slack Scope Management & Troubleshooting ‚úÖ CRITICAL
- **Required Bot Scopes**: All Slack functionality depends on having correct bot token scopes configured
- **Scope Configuration Files**:
  - Code: [src/lib/slack.ts](mdc:src/lib/slack.ts) - `slackOAuthConfig.botScopes` array  
  - Manifest: [manifest.json](mdc:manifest.json) - `oauth_config.scopes.bot` array
- **Critical Scopes for Core Functionality**:
  - `chat:write` - Send messages to channels (REQUIRED)
  - `chat:write.customize` - Custom username/avatar for message replacement
  - `im:write` - Send direct messages to users (REQUIRED for welcome messages)
  - `message.channels` event subscription requires proper scopes
- **Common Issues Fixed**:
  - Missing `message.channels` in event subscriptions (prevented auto coaching)
  - Incorrect interactive endpoint URL (`/interactions` vs `/interactive`)
  - Missing `chat:write.customize` scope for message replacement
  - Using global bot token instead of workspace-specific tokens
- **Troubleshooting Process**:
  1. Check error logs for `missing_scope` messages
  2. Identify which API method is failing
  3. Look up required scopes in Slack API docs
  4. Add missing scopes to both `src/lib/slack.ts` and `manifest.json`
  5. Update Slack app configuration in developer console
  6. Reinstall app to get new permissions
- **Essential Bot Scopes List**:
  ```typescript
  botScopes: [
    'chat:write',        // Send messages
    'chat:write.public', // Send to channels bot isn't in
    'chat:write.customize', // Custom username/avatar for replacements
    'commands',          // Slash commands
    'channels:history',  // Read message history
    'groups:history',    // Read private channel history  
    'channels:read',     // Read channel info
    'channels:join',     // Join channels during onboarding
    'groups:read',       // Read private channel info
    'im:write',          // Send DMs (CRITICAL for welcome messages)
    'users:read',        // Read user info
    'app_mentions:read'  // Handle @mentions
  ]
  ```

## Welcome Message Implementation ‚úÖ COMPLETED
- **Functionality**: Personalized welcome message sent via DM after Slack app installation
- **Implementation**: [src/lib/slack.ts](mdc:src/lib/slack.ts) - `sendWelcomeMessage()` function
- **Integration**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts) - Called after OAuth success
- **Message Features**:
  - Rich Block Kit formatting with interactive buttons
  - "Complete Setup" button linking to onboarding
  - "Help Center" button for documentation  
  - Clear value proposition and next steps
  - Privacy reassurance (feedback is private)
- **Error Handling**: Graceful failure - doesn't break OAuth flow if DM fails
- **Critical Dependency**: Requires `im:write` scope for DM functionality
- **Follow-up System**: `sendOnboardingReminderMessage()` for incomplete users

## API Architecture
- **Use Server Actions**: Prefer Next.js Server Actions over API routes for most functionality
- **API routes only for**:
  - Slack OAuth callback and webhook endpoints
  - Slack commands, events, and interactive components
  - Webhook endpoints from external services
  - Third-party integrations that require traditional REST endpoints
  - Demo bots and testing endpoints (e.g., `/api/demo`)
- **Server Actions for**:
  - Database operations (with workspace-specific token lookups)
  - Form submissions and onboarding flow
  - Data mutations and channel management
  - Business logic and AI operations
- **Workspace Token Pattern**: Server actions fetch workspace-specific bot tokens from database before making Slack API calls
- **Demo Bot Pattern**: Simple single-file implementations in `/api/demo` with separate environment variables and minimal dependencies
- **Import Standards**: All API routes use static imports only - see Import Management section for details

## Project Structure Reference
- **Auth pages**: [src/app/(auth)/](mdc:src/app/(auth)/) - Login, register, etc.
- **App pages**: [src/app/app/](mdc:src/app/app) - Protected application pages (no route group)
- **Public pages**: [src/app/(public)/](mdc:src/app/(public)/) - Landing and public pages
- **API routes**: [src/app/api/](mdc:src/app/api) - Only for auth and specific endpoints
- **Components**: [src/components/](mdc:src/components) - Organized by section (ui, auth, app, common)
- **Server Actions**: [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) for shared database operations

## Current Implementation Snapshot (January 2025)

_This snapshot helps you quickly navigate the existing codebase. It will become outdated as files change, so update it when major structural changes occur._

### Root Directories
- **Source code**: [src/](mdc:src)
  - **Application routes**: [src/app/](mdc:src/app)
  - **Shared libraries & helpers**: [src/lib/](mdc:src/lib)
  - **Global React context**: [src/context/](mdc:src/context) (currently empty)
  - **Reusable components**: [src/components/](mdc:src/components)
  - **Type definitions**: [src/types/](mdc:src/types)
  - **Custom hooks**: [src/hooks/](mdc:src/hooks)

### Key Route Groups
1. **Public Pages** ‚Äî [src/app/(public)/](mdc:src/app/(public)/) 
   - Landing page with Slack installation: [src/app/(public)/page.tsx](mdc:src/app/(public)/page.tsx)
   - Marketing and public content

2. **App Pages** ‚Äî [src/app/app/](mdc:src/app/app) (no auth needed - Slack app)
   - Onboarding flow: [src/app/app/onboarding/page.tsx](mdc:src/app/app/onboarding/page.tsx)
   - Help documentation: [src/app/app/help/page.tsx](mdc:src/app/app/help/page.tsx)  
   - Team invitations: [src/app/app/invite/page.tsx](mdc:src/app/app/invite/page.tsx)

3. **API Routes** ‚Äî [src/app/api/](mdc:src/app/api) ‚úÖ OPTIMIZED
   - Slack OAuth callback: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts)
   - Slack commands: [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts)
   - Slack events: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts)
   - Slack interactive: [src/app/api/slack/interactive/route.ts](mdc:src/app/api/slack/interactive/route.ts)
   - Stripe checkout: [src/app/api/stripe/checkout/route.ts](mdc:src/app/api/stripe/checkout/route.ts)
   - Stripe portal: [src/app/api/stripe/portal/route.ts](mdc:src/app/api/stripe/portal/route.ts)
   - Stripe webhooks: [src/app/api/stripe/webhooks/route.ts](mdc:src/app/api/stripe/webhooks/route.ts)
   - Demo bot: [src/app/api/demo/route.ts](mdc:src/app/api/demo/route.ts) - Single-file AI reply bot for testing
   - **Import Standard**: All routes use static imports for optimal performance and type safety

### Middleware & Authentication
- **Middleware**: [src/middleware.ts](mdc:src/middleware.ts) - Protects `/app/*` routes with session validation and onboarding flow
- **Auth Configuration**: [src/lib/auth.ts](mdc:src/lib/auth.ts) - Better-auth setup
- **Auth Client**: [src/lib/auth-client.ts](mdc:src/lib/auth-client.ts) - Browser-side auth utilities

### Library & Utility Files
- **MongoDB client**: [src/lib/db.ts](mdc:src/lib/db.ts) - Native MongoDB driver connection
- **Server actions**: [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) - Database operations and business logic
- **AI Integration**: [src/lib/ai.ts](mdc:src/lib/ai.ts) - Azure OpenAI powered AI functions for auto-coaching
- **AI Prompts**: [src/lib/prompts/index.ts](mdc:src/lib/prompts/index.ts) - Centralized AI prompt templates (includes contextual variants for rephrase)
- **Theme configuration**: [src/lib/theme.ts](mdc:src/lib/theme.ts)
- **Utilities**: [src/lib/utils.ts](mdc:src/lib/utils.ts)

### API Routes
- **Auth**: [src/app/api/auth/[...all]/route.ts](mdc:src/app/api/auth/[...all]/route.ts) - Better-auth handler
- **User**: [src/app/api/user/route.ts](mdc:src/app/api/user/route.ts) - User data endpoint for middleware

### UI Component Folders
- **UI wrappers**: [src/components/ui/](mdc:src/components/ui) - Comprehensive UI component library
- **Auth-specific components**: [src/components/auth/](mdc:src/components/auth) (currently empty)

### Data & Types
- **Type definitions**: [src/types/index.ts](mdc:src/types/index.ts) - Simplified Zod schemas and TypeScript types
- **No Mongoose Models**: Database operations use native MongoDB driver with Zod schemas for validation

### Styling & Theme
- **Global CSS**: [src/app/globals.css](mdc:src/app/globals.css)
- **Mantine Provider & fonts**: [src/app/layout.tsx](mdc:src/app/layout.tsx)

## Validation & Schema Management
- **Use Zod for validation**: Always use Zod schemas for data validation instead of manual checking
- **Schema location**: Define Zod schemas in [src/types/index.ts](mdc:src/types/index.ts) alongside TypeScript interfaces
- **Validation pattern**: Create Zod schemas that can infer TypeScript types, ensuring single source of truth
- **Server actions**: Use Zod schemas to validate inputs in server actions before processing
- **Form validation**: Use Zod schemas with form libraries for client-side validation
- **API validation**: Validate all incoming data using Zod schemas
- **Database validation**: Use Zod schemas to validate data before MongoDB operations
- **Example pattern**:
  ```typescript
  // Define Zod schema first
  export const UserConfigSchema = z.object({
    websiteUrl: z.string().url(),
    companyName: z.string().min(1),
    // ... other fields
  });
  
  // Infer TypeScript type from schema
  export type UserConfig = z.infer<typeof UserConfigSchema>;
  
  // Use in MongoDB operations
  const validatedData = UserConfigSchema.parse(rawData);
  await db.collection('configs').insertOne(validatedData);
  ```

## Onboarding Flow Implementation ‚úÖ UPDATED
- **Multi-step form**: [src/app/app/onboarding/OnboardingForm.tsx](mdc:src/app/app/onboarding/OnboardingForm.tsx) handles Slack user onboarding
- **User Identification**: Query parameters (`?user={slackId}&team={teamId}`) for validation
- **Step Flow**: `frequency` ‚Üí `channels` ‚Üí `payment` ‚Üí complete
  - **Step 1**: Analysis frequency selection (weekly/monthly)
  - **Step 2**: Channel selection - users choose which channels to enable AI coaching
  - **Step 3**: Payment plan selection - Free vs Pro with dynamic pricing cards
- **Payment Step Features**:
  - **Congratulations Message**: "üéâ You're all set up! Get even more features with our Pro plan."
  - **Side-by-Side Cards**: FREE and PRO plans using `SUBSCRIPTION_TIERS` data
  - **Dynamic Container Width**: Adjusts from 480px to 640px for payment step to accommodate horizontal cards
  - **Mantine Layout**: Uses `Row justify="center"` with proper flex properties for horizontal card display
  - **Button Actions**: 
    - Free: "Continue with Free" ‚Üí completes onboarding ‚Üí `/app/help`
    - Pro: "Upgrade to Pro" ‚Üí Stripe checkout ‚Üí `/app/help` after success
- **Server Actions**: 
  - `validateSlackUser()` - Validates user and checks onboarding status
  - `getWorkspaceChannels()` - Fetches available channels using workspace-specific bot token
  - `saveBotChannels()` - Joins bot to selected channels and stores in database
  - `completeSlackOnboarding()` - Saves preferences, channels, and marks onboarding complete
- **Layout Patterns**:
  - **Container Responsive Width**: `maxWidth: currentStep === 'payment' ? 640 : 480`
  - **Card Flex Properties**: `minWidth: 280, maxWidth: 280, flexShrink: 0`
  - **Row Layout**: `<Row justify="center" gap={24} wrap="wrap" align="stretch">`
- **One-time completion**: `hasCompletedOnboarding` flag prevents re-access
- **Bot Integration**: Bot automatically joins selected channels during onboarding
- **Completion**: Sets `hasCompletedOnboarding: true` on user document for middleware routing

## Key Collections ‚úÖ UPDATED
- **workspaceCollection**: Slack workspace/team data (workspaceId, name, domain, **botToken**)
- **slackUserCollection**: Slack user data with onboarding tracking and **subscription** field (slackId, analysisFrequency, hasCompletedOnboarding, **subscription**)
- **botChannelsCollection**: Tracks which channels bot is active in (workspaceId, channelId, channelName, addedAt)
- **invitationCollection**: Email invitations sent by users during onboarding
- **analysisInstanceCollection**: Future - will store message analysis results
- **Legacy collections**: userCollection, accountConfigCollection (for reference only)

## Payment & Subscription Architecture ‚úÖ IMPLEMENTED

### Subscription System Overview
- **Provider**: Stripe for payment processing and subscription management
- **Tiers**: FREE (default) and PRO (paid) tiers with feature limits
- **Billing**: Monthly billing cycles with automatic usage reset
- **User-Based**: All limits and pricing are per-user, not per-workspace
- **No Admin Dashboard**: Backend-only implementation with Stripe handling UI

### Subscription Configuration ‚úÖ CENTRALIZED
- **Configuration Location**: [src/types/index.ts](mdc:src/types/index.ts) - All subscription types, tiers, and pricing
- **Subscription Tiers**:
  ```typescript
  export const SUBSCRIPTION_TIERS = {
    FREE: {
      name: 'Free',
      price: 0,
      monthlyLimits: {
        autoCoaching: 50,      // Auto coaching suggestions
        manualRephrase: 10,    // Manual /rephrase commands  
        personalFeedback: 2,   // Personal feedback reports
      },
      features: {
        basicAnalysis: true,   // Basic AI analysis
        weeklyReports: false,  // Weekly communication reports
        prioritySupport: false // Priority customer support
      }
    },
    PRO: {
      name: 'Pro',
      price: 2000, // $20.00 in cents
      monthlyLimits: {
        autoCoaching: -1,      // Unlimited
        manualRephrase: -1,    // Unlimited
        personalFeedback: -1,  // Unlimited
      },
      features: {
        basicAnalysis: true,
        weeklyReports: true,
        prioritySupport: true
      }
    }
  } as const;
  ```

### Database Schema Integration ‚úÖ IMPLEMENTED
- **Subscription Field**: Added to `SlackUserSchema` in [src/types/index.ts](mdc:src/types/index.ts)
- **Schema Structure**:
  ```typescript
  export const SubscriptionSchema = z.object({
    tier: z.enum(['FREE', 'PRO']).default('FREE'),
    status: z.enum(['active', 'cancelled', 'past_due']).default('active'),
    currentPeriodStart: z.coerce.date(),
    currentPeriodEnd: z.coerce.date(),
    stripeCustomerId: z.string().optional(),
    stripeSubscriptionId: z.string().optional(),
    monthlyUsage: z.object({
      autoCoaching: z.number().default(0),
      manualRephrase: z.number().default(0),
      personalFeedback: z.number().default(0),
    }),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
  });
  ```

### Subscription Management Functions ‚úÖ IMPLEMENTED
- **Location**: [src/lib/subscription.ts](mdc:src/lib/subscription.ts) - Individual server functions
- **Core Functions**:
  - `validateUserAccess(userId, feature)` - Check subscription limits and access
  - `incrementUsage(userId, feature)` - Track feature usage
  - `updateSubscription(userId, updates)` - Update subscription data
  - `resetMonthlyUsage(userId)` - Reset usage counters for new billing period
  - `getSubscriptionStatus(userId)` - Get current subscription and usage info
  - `needsBillingReset(userId)` - Check if billing period reset is needed

### Access Control Integration ‚úÖ IMPLEMENTED
- **Command Integration**: All Slack commands check subscription limits before processing
- **Auto Coaching**: Event handler validates access before AI analysis
- **Usage Tracking**: Increment counters after successful feature usage
- **Rate Limiting**: Monthly limits enforced with user-friendly messages

### Stripe Integration ‚úÖ IMPLEMENTED

#### Stripe Configuration
- **Client Setup**: [src/lib/stripe.ts](mdc:src/lib/stripe.ts) - Stripe client with API version `2025-07-30.basil`
- **Price IDs**: Defined in [src/types/index.ts](mdc:src/types/index.ts) for environment-specific pricing
- **Webhook Endpoint**: [src/app/api/stripe/webhooks/route.ts](mdc:src/app/api/stripe/webhooks/route.ts)

#### Stripe API Endpoints
- **Checkout**: [src/app/api/stripe/checkout/route.ts](mdc:src/app/api/stripe/checkout/route.ts) - Create checkout sessions
- **Customer Portal**: [src/app/api/stripe/portal/route.ts](mdc:src/app/api/stripe/portal/route.ts) - Manage subscriptions
- **Webhooks**: [src/app/api/stripe/webhooks/route.ts](mdc:src/app/api/stripe/webhooks/route.ts) - Handle Stripe events

#### Webhook Event Handling ‚úÖ ENHANCED
- **Supported Events**:
  - `checkout.session.completed` - New subscription creation **with existing subscription sync**
  - `customer.subscription.created` - Subscription activation
  - `customer.subscription.updated` - Subscription changes
  - `customer.subscription.resumed` - Subscription resumption
  - `customer.subscription.deleted` - Subscription cancellation
  - `customer.updated` - Customer portal interactions (fallback sync)
  - `invoice.payment_succeeded` - Successful payment processing
  - `invoice.payment_failed` - Failed payment handling
- **Enhanced Checkout Handling**: Proactively syncs existing subscriptions when no webhook is sent
- **Customer Portal Support**: Handles "Use existing subscription" flow without webhook events

#### Type Safety with Stripe ‚úÖ RESOLVED
- **Challenge**: Stripe TypeScript definitions don't include all runtime properties
- **Solution**: Use proper type casting for accessing runtime properties
- **Pattern**:
  ```typescript
  // Access properties that exist at runtime but not in TypeScript definitions
  const subscriptionData = subscription as unknown as Record<string, unknown>;
  const currentPeriodStart = subscriptionData.current_period_start as number;
  
  const invoiceData = invoice as unknown as Record<string, unknown>;
  const subscriptionId = invoiceData.subscription as string;
  ```

### User Initialization ‚úÖ IMPLEMENTED
- **OAuth Integration**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts)
- **Default Subscription**: New users get FREE tier with active status and zero usage
- **Initialization Pattern**:
  ```typescript
  const defaultSubscription = {
    tier: 'FREE' as const,
    status: 'active' as const,
    currentPeriodStart: new Date(),
    currentPeriodEnd: nextMonth,
    monthlyUsage: {
      autoCoaching: 0,
      manualRephrase: 0,
      personalFeedback: 0,
    },
    createdAt: new Date(),
    updatedAt: new Date(),
  };
  ```

### Feature Access Patterns ‚úÖ IMPLEMENTED

#### Pre-Feature Validation
```typescript
// Before processing any feature
const accessCheck = await validateUserAccess(userId, 'autoCoaching');
if (!accessCheck.allowed) {
  if (accessCheck.upgradeRequired) {
    return generateUpgradeMessage('autoCoaching', accessCheck.reason, userId);
  }
  return generateLimitReachedMessage('autoCoaching', currentUsage, limit, resetDate, userId);
}
const user = accessCheck.user!; // User is included in successful validation
```

#### Post-Feature Usage Tracking
```typescript
// After successful feature usage (in background)
after(async () => {
  if (success) {
    await incrementUsage(userId, 'autoCoaching');
  }
});
```

### User Experience Messages ‚úÖ IMPLEMENTED
- **Upgrade Messages**: Professional upgrade prompts with Stripe checkout links
- **Limit Reached**: Friendly messages showing current usage and reset dates
- **Slack Formatting**: Uses proper Slack mrkdwn formatting (`*bold*`, `_italic_`)

### Billing Cycle Management ‚úÖ IMPLEMENTED
- **Monthly Reset**: Usage counters reset on billing anniversary date
- **Automatic Processing**: Webhook handlers manage billing period updates
- **Grace Period**: No interruption during payment processing

### Environment Configuration
- **Stripe Keys**: `STRIPE_SECRET_KEY`, `STRIPE_PUBLISHABLE_KEY`, `STRIPE_WEBHOOK_SECRET`
- **Price IDs**: Environment-specific Stripe price identifiers
- **Database**: Subscription data stored in existing MongoDB collections

### Best Practices ‚úÖ ENFORCED
- **Single User Fetch**: `validateUserAccess` fetches user once and includes in result
- **Background Processing**: Usage tracking happens in `after()` blocks
- **Type Safety**: Proper Zod validation for all subscription data
- **Error Handling**: Graceful degradation when Stripe operations fail
- **Consistency**: All subscription logic centralized in dedicated functions

## Trigger.dev Background Jobs Architecture

### What is Trigger.dev?
**Trigger.dev** is a powerful background job and AI infrastructure platform that enables developers to write reliable, long-running workflows in normal async code. It handles queues, elastic scaling, retries, observability, and zero infrastructure management.

**Key Features:**
- **No timeouts**: Write simple, reliable code that never hits timeouts
- **Pay for what you use**: Only pay when code is actually executing
- **No servers to manage**: Automatic deployment and scaling
- **Observability**: Real-time monitoring and tracing of tasks
- **Retries**: Automatic retrying with configurable strategies
- **AI integration**: Built-in support for AI agents and LLM workflows

**Documentation**: [https://trigger.dev/docs](https://trigger.dev/docs)

### Project Integration

#### Configuration
- **Config file**: [trigger.config.ts](mdc:trigger.config.ts) - Main Trigger.dev configuration
- **Task location**: [src/trigger/](mdc:src/trigger/) - All background tasks
- **Environment variables**: Use `TRIGGER_API_KEY` and `TRIGGER_API_URL` for deployment

#### Task Structure
```typescript
// Example task pattern
import { task } from "@trigger.dev/sdk/v3";

export const exampleTask = task({
  id: "example-task",
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 5000,
  },
  run: async (payload, { ctx }) => {
    // Your async logic here
    console.log("Task executed:", payload);
    
    return { success: true, data: "Task completed" };
  },
});
```

#### Current Implementation
- **Generic task**: [src/trigger/generateCreative.ts](mdc:src/trigger/generateCreative.ts) - Simplified example task
- **Task ID**: Uses environment variable `TRIGGER_TASK_ID` for generic naming
- **Purpose**: Demonstrates basic Trigger.dev integration pattern

#### Best Practices
- **Task naming**: Use descriptive, generic names that can be reused
- **Error handling**: Implement proper error handling with retry logic
- **Payload validation**: Validate input payloads using Zod schemas
- **Logging**: Use structured logging for observability
- **Environment separation**: Use different task IDs for dev/prod environments

#### Common Use Cases
- **AI workflows**: Long-running AI operations with LLM chains
- **Data processing**: Batch operations and ETL processes
- **Scheduled tasks**: Cron jobs and periodic operations
- **Webhook processing**: Handle external service webhooks
- **Email campaigns**: Bulk email processing and delivery
- **File processing**: Image, video, and document processing

#### Development Workflow
1. **Local development**: Use Trigger.dev CLI for local testing
2. **Task deployment**: Deploy tasks to Trigger.dev cloud
3. **Monitoring**: Use Trigger.dev dashboard for observability
4. **Debugging**: Use run logs and tracing for troubleshooting

#### Integration with Next.js
- **Server Actions**: Trigger tasks from server actions
- **API Routes**: Use for webhook endpoints that trigger tasks
- **Client-side**: Use Trigger.dev React hooks for real-time updates
- **Environment**: Configure for different deployment environments

## Azure OpenAI Integration ‚úÖ IMPLEMENTED

### Configuration
- **Provider**: Azure OpenAI using official `openai` SDK with `AzureOpenAI` client
- **Environment Variables**:
  - `AZURE_API_KEY` - Azure OpenAI API key (required)
  - `AZURE_API_ENDPOINT` - Azure endpoint URL (required)
  - `AZURE_API_VERSION` - API version (defaults to '2024-12-01-preview')
  - `AZURE_DEPLOYMENT_NAME` - Model deployment name (defaults to 'gpt-4')
  - `AZURE_MODEL_NAME` - Optional model name override

### AI Architecture ‚úÖ OPTIMIZED
- **Client Setup**: [src/lib/ai.ts](mdc:src/lib/ai.ts) - Single `AzureOpenAI` client instance
- **Prompt Management**: [src/lib/prompts/index.ts](mdc:src/lib/prompts/index.ts) - Centralized prompt templates with GPT-5 best practices
- **JSON Response Format**: All AI functions use `response_format: { type: 'json_object' }` with explicit JSON instructions
- **Performance Config**: `reasoning_effort: 'low'` for optimized speed vs. quality balance
- **Model**: GPT-5 (or gpt-5-nano) via Azure OpenAI deployment

### Auto-Coaching Workflow ‚úÖ OPTIMIZED (Single AI Call)
1. **Step 1: Always Fetch Context** - Get conversation history for better analysis
   - Fetch last 15 messages from Slack API for all messages
   - Provides context for more accurate analysis

2. **Step 2: Comprehensive Analysis** - Single AI call handles everything
   - Uses `comprehensiveMessageAnalysis()` - one AI call replaces 4 separate calls
   - Performs screening, detailed analysis, target identification, and message improvement
   - **75% faster** and **75% cheaper** than previous multi-call approach

3. **Step 3: Send Coaching** - Only if issues found
   - Ephemeral feedback with improved message suggestions
   - Interactive buttons for message replacement

### AI Functions Implemented
**Auto-Coaching (Optimized):**
- **`comprehensiveMessageAnalysis()`** - Single AI call for complete analysis (NEW)

**Manual Commands (Preserved):**
- **`analyzeMessageForFlags()`** - Detailed analysis with context (for `/personalfeedback`)
- **`analyzeMessageForRephraseWithoutContext()`** - Context-free analysis for `/rephrase`
- **`analyzeMessageForRephraseWithContext()`** - Context-aware analysis for `/rephrase`
- **`generateImprovedMessage()`** - Basic message improvements for `/rephrase`
- **`generateImprovedMessageWithContext()`** - Context-aware improvements for `/rephrase`
- **`generatePersonalFeedback()`** - User communication patterns analysis
- **`generateReport()`** - Weekly/monthly communication reports

**Legacy Functions (Removed):**
- ~~`quickCheckNeedsCoaching()`~~ - Replaced by comprehensive analysis
- ~~`identifyMessageTarget()`~~ - Integrated into comprehensive analysis

### Prompt Design Principles ‚úÖ UPDATED (GPT-5 Best Practices)
- **Conservative by default** - Don't flag normal professional communication
- **Explicit JSON format** - Required for Azure OpenAI `json_object` mode
- **Context separation** - Clear distinction between current message and history
- **Specific examples** - Concrete examples of what to flag/not flag
- **Tone adaptation** - Match user's tone, register, and formality in improvements
- **Human-like output** - Avoid AI-ish phrasing, hedging, or generic filler
- **Slack-specific preservation** - Keep @mentions, <#channel> references, links, code
- **Natural length** - Keep approximately same length unless brevity obviously helps

### Contextual Analysis Patterns ‚úÖ NEW
- **Conditional Context Usage**: `/rephrase` command intelligently uses conversation history when bot has channel access
- **Channel Access Detection**: Uses `isChannelAccessible()` to determine if bot can fetch conversation history
- **Dual Analysis Paths**:
  - **With Context**: `analyzeMessageForRephraseWithContext()` - Uses last 10 messages for better understanding
  - **Without Context**: `analyzeMessageForRephraseWithoutContext()` - Analyzes only the provided message text
- **Context-Aware Improvements**: `generateImprovedMessageWithContext()` creates suggestions that fit conversation flow
- **Privacy-First**: Only accesses conversation data when bot is explicitly added to channels

## Slack Slash Command Modal Responses
- When a slash command opens a modal via `views.open`, **never** wait for the API call to resolve before responding to Slack.
- Respond with an **empty 200 OK** (no JSON body) or `null` in Next.js API routes to acknowledge the request immediately.
- This prevents Slack from posting a `Slackbot` operation_timeout error or showing "We had some trouble connecting" banners.
- Handle any async work (e.g., DB updates, secondary API calls) in the background and log errors instead of blocking the response.

## Using `after()` for background tasks (Next.js 15)
- When running on Vercel, prefer Next.js `after()` from `next/server` to schedule any asynchronous work (DB writes, external API calls, logging) **after** the HTTP response has been sent.
- Pattern:
  ```ts
  import { after } from 'next/server';

  // inside route handler
  after(async () => {
    await doLongTask();
  });

  return new Response(null, { status: 200 });
  ```
- This guarantees the work completes (or errors) without risking Slack‚Äôs 3-second timeout and without dropping promises when the serverless invocation ends.
- Continue to respond to Slack immediately (empty 200 or minimal JSON) before the 3-second window.

## Enhanced Rephrase Command Implementation ‚úÖ COMPLETED

### Contextual Analysis Workflow
The `/rephrase` command now intelligently adapts based on bot channel permissions:

**Implementation Pattern:**
```typescript
// Check if bot has channel access
const hasChannelAccess = await isChannelAccessible(channelId, user.workspaceId);

if (hasChannelAccess) {
    // Fetch last 10 messages for context
    const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 10);
    // Use context-aware analysis
    const analysisResult = await analyzeMessageForRephraseWithContext(text, conversationHistory);
    // Generate context-aware improvements
    const improvedMessage = await generateImprovedMessageWithContext(text, primaryFlag.type, conversationHistory);
} else {
    // Analyze without context
    const analysisResult = await analyzeMessageForRephraseWithoutContext(text);
    // Generate basic improvements
    const improvedMessage = await generateImprovedMessage(text, primaryFlag.type);
}
```

### Key Features ‚úÖ IMPLEMENTED
- **Conditional Context Fetching**: Only fetches conversation history when bot is channel member
- **Timeout Prevention**: Uses `after()` for background AI processing, responds immediately
- **Ephemeral Results**: Shows suggestions as private ephemeral messages in same channel
- **Clean Interface**: Simple format with original, improved, and tone information
- **Privacy-First**: Conversation history only accessed when explicitly authorized

### User Experience
1. User runs `/rephrase Can you get this done ASAP?`
2. Immediate response: "‚è≥ Analyzing and rephrasing your message..."
3. Background analysis completes (context-aware if bot in channel)
4. Ephemeral result shows improved message with tone information

## User Settings & Preferences ‚úÖ IMPLEMENTED

### Settings Command Implementation
- **Command**: `/settings` - Opens modal for user preference management
- **Modal Interface**: Clean, unified settings modal with two main options
- **Settings Available**:
  - **Report Frequency**: Weekly or Monthly (radio buttons)
  - **Auto Rephrase**: Enable/disable automatic coaching suggestions (checkbox)

### Settings Modal Design
- **No Current Settings Display**: Modal shows only the input controls
- **Simplified Labels**: "Auto Rephrase" (not "Auto Rephrase Suggestions")
- **Clean Interface**: No dividers or current status text
- **Help Text**: Context about manual `/rephrase` command when auto is disabled

### Settings Persistence
- **Database Field**: `autoRephraseEnabled: boolean` in SlackUser schema (default: true)
- **Immediate Update**: Settings saved in background using `after()` for fast response
- **Success Feedback**: Modal updates to show "‚úÖ Settings updated" message
- **Modal Behavior**: Stays open after save, user closes manually

### Auto Coaching Control
- **Preference Check**: Auto coaching respects `autoRephraseEnabled` setting
- **Event Processing**: Skip analysis if `user.autoRephraseEnabled === false`
- **Manual Override**: `/rephrase` command always works regardless of auto setting
- **Default Behavior**: New users get auto coaching enabled by default

### Implementation Files
- **Settings Modal**: [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts) - `/settings` command handler
- **Settings Handler**: [src/app/api/slack/interactive/route.ts](mdc:src/app/api/slack/interactive/route.ts) - Modal submission processing
- **Auto Coaching Check**: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts) - Preference validation
- **User Creation**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts) - OAuth with default settings

## Slack Integration Best Practices ‚úÖ CRITICAL UPDATES

### Workspace-Specific Token Usage Pattern ‚úÖ MANDATORY
**Never use global bot tokens - always use workspace-specific tokens from database:**

```typescript
// ‚ùå WRONG - Global token causes auth errors
const conversationHistory = await fetchConversationHistory(channelId, process.env.SLACK_BOT_TOKEN!, undefined, 40);

// ‚úÖ CORRECT - Workspace-specific token
const user = await slackUserCollection.findOne({ slackId: userId, isActive: true });
const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 40);
```

**Why this matters:**
- Each workspace has its own bot token from OAuth installation
- Global tokens cause `invalid_auth` errors in multi-workspace environments  
- Workspace-specific tokens ensure proper permissions and isolation

### Slack Markdown Formatting ‚úÖ CRITICAL
**Use Slack's mrkdwn format, not standard Markdown:**

```typescript
// ‚ùå WRONG - Standard Markdown (doesn't render in Slack)
const message = `**Personal Communication Feedback**\n**Overall Score**: 8/10\n*Analysis based on recent messages.*`;

// ‚úÖ CORRECT - Slack mrkdwn format
const message = `*Personal Communication Feedback*\n*Overall Score*: 8/10\n_Analysis based on recent messages._`;
```

**Slack formatting rules:**
- **Bold**: Use `*text*` (single asterisks)
- **Italic**: Use `_text_` (underscores)  
- **Code**: Use backticks `` `code` ``
- **Channels**: Use `<#channelId>` for channel references
- **Users**: Use `<@userId>` for user mentions

### Human-Only Message Filtering ‚úÖ IMPLEMENTED
**Enhanced conversation history filtering to only include human messages:**

```typescript
// In fetchConversationHistory - comprehensive filtering
const messages = result.messages
  .filter(msg => {
    // Must have text content
    if (!msg.text || msg.text.trim() === '') return false;
    
    // Filter out all bot messages
    if (msg.bot_id || msg.app_id) return false;
    
    // Filter out system messages by subtype
    if (msg.subtype && [
      'bot_message', 'channel_join', 'channel_leave', 'channel_topic',
      'channel_purpose', 'file_share', 'slackbot_response'
    ].includes(msg.subtype)) return false;
    
    // Must have a human user ID (starts with 'U')
    if (!msg.user || !msg.user.startsWith('U')) return false;
    
    // Filter out slash commands and standalone mentions
    const text = msg.text.trim();
    if (text.startsWith('/') || text.match(/^<@[UW][A-Z0-9]+>$/)) return false;
    
    return true;
  })
  .map(msg => msg.text || '')
  .reverse(); // Chronological order
```

### Background Processing with Timeout Prevention ‚úÖ IMPLEMENTED
**Slack command pattern with immediate response and background analysis:**

```typescript
// Personal feedback command example
async function handlePersonalFeedback(userId: string, channelId: string) {
  // Get user and workspace information
  const user = await slackUserCollection.findOne({ slackId: userId, isActive: true });
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  
  // Schedule background analysis using after()
  after(async () => {
    try {
      // Heavy analysis work (conversation history + AI)
      const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 40);
      const feedback = await generatePersonalFeedback(conversationHistory);
      
      // Add relationship insights
      const relationshipInsights = await analyzeRelationshipContext(conversationHistory);
      
      // Send formatted results via DM
      const formattedMessage = formatPersonalFeedbackMessage(feedback, relationshipInsights, channelId);
      await sendDirectMessage(userId, formattedMessage, workspace.botToken);
    } catch (error) {
      await sendDirectMessage(userId, 'Error generating report', workspace.botToken);
    }
  });

  // Immediately return processing message 
  return {
    text: '‚è≥ *Analyzing your communication patterns...*\n\nI\'ll send the detailed analysis to your DMs shortly!',
    response_type: 'ephemeral'
  };
}
```

### Relationship-Specific Coaching Insights ‚úÖ IMPLEMENTED
**Analyze individual messages to identify communication targets:**

```typescript
// Analyze recent messages for relationship context
let relationshipInsights: { name: string; issues: string[] }[] = [];
const relationshipMap = new Map<string, string[]>();

for (const message of recentMessages) {
  const analysis = await analyzeMessageForFlags(message, conversationHistory);
  if (analysis.flags.length > 0 && analysis.target?.name) {
    const issues = relationshipMap.get(analysis.target.name) || [];
    analysis.flags.forEach(flag => {
      if (!issues.includes(flag.type)) issues.push(flag.type);
    });
    relationshipMap.set(analysis.target.name, issues);
  }
}

// Only show if we have real person names (not "Unknown")
if (relationshipInsights.some(insight => insight.name && insight.name !== 'Unknown')) {
  feedbackMessage += `üë• *Relationship insights:*\n`;
  feedbackMessage += relationshipInsights
    .filter(insight => insight.name !== 'Unknown')
    .map(insight => `‚Ä¢ Work on *${insight.issues.join(', ')}* when messaging *${insight.name}*`)
    .join('\n');
}
```

### Friendly Coaching Tone ‚úÖ IMPLEMENTED
**Use supportive, personal language instead of formal reports:**

```typescript
// ‚ùå FORMAL - Sounds like a report
const responseText = `Communication Report\nOverall Score: 8/10\nAreas for Improvement:\n‚Ä¢ Be more specific`;

// ‚úÖ COACHING - Friendly and supportive
const responseText = `ü§ñ *Hey there! Here's your personal feedback*\n` +
  `*How you're doing: ${score}/10* ${score >= 8 ? 'üü¢ You\'re crushing it!' : 'üî¥ Let\'s level up together!'}\n` +
  `üí™ *Let's work on these together:*\n‚Ä¢ Be more specific in your requests`;
```

**Coaching language patterns:**
- "Hey there!" instead of formal greetings
- "How you're doing" instead of "Overall Score"  
- "Let's work on these together" instead of "Areas for Improvement"
- "Here's what I'd love to see you try next" instead of "Action Items"
- Encouraging emojis and supportive tone throughout

## Stripe Billing Portal Integration ‚úÖ IMPLEMENTED

### Settings Modal with Billing Section
The `/settings` command now includes integrated billing management:

```typescript
// Settings modal with billing section
const modal = {
  blocks: [
    // ... existing settings (frequency, auto rephrase)
    {
      type: 'divider'
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Billing & Subscription*\n${subscriptionStatusText}`
      },
      accessory: {
        type: 'button',
        text: {
          type: 'plain_text',
          text: billingButtonText,
          emoji: true
        },
        ...(isPaidUser ? {} : { style: 'primary' }),
        url: billingUrl,
        action_id: 'billing_action'
      }
    }
  ]
};
```

### Subscription Tier Configuration ‚úÖ UPDATED
**Current subscription structure in [src/types/index.ts](mdc:src/types/index.ts):**

```typescript
export const SUBSCRIPTION_TIERS = {
  FREE: {
    name: 'Free',
    price: 0,
    monthlyLimits: {
      autoCoaching: 50,        // messages per month
      manualRephrase: 50,      // messages per month  
      personalFeedback: 5,     // reports per month
    },
    features: {
      reports: true,
      advancedReportAnalytics: false
    }
  },
  PRO: {
    name: 'Pro', 
    price: 10, // $10/month
    monthlyLimits: {
      autoCoaching: 1000,      // messages per month
      manualRephrase: 1000,    // messages per month  
      personalFeedback: 100,   // reports per month
    },
    features: {
      reports: true,
      advancedReportAnalytics: true
    }
  }
} as const;
```

### MongoDB ObjectId Integration ‚úÖ CRITICAL
**All Stripe operations now use MongoDB `_id` instead of `slackId`:**

```typescript
// ‚úÖ CORRECT - Use MongoDB ObjectId for Stripe operations
const billingUrl = isPaidUser 
  ? `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/api/stripe/portal?user=${encodeURIComponent(user._id)}`
  : `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/api/stripe/checkout?user=${encodeURIComponent(user._id)}`;

// ‚úÖ CORRECT - Convert ObjectId to string for Stripe
const session = await createCheckoutSession(
  user._id.toString(), // Convert to string
  STRIPE_PRICE_IDS.PRO_MONTHLY,
  '', // Use Stripe default success page
  `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/app/help` // Back button redirect
);

// ‚úÖ CORRECT - Convert string back to ObjectId for database queries
const user = await slackUserCollection.findOne({ 
  _id: new ObjectId(userId) // Convert string back to ObjectId
});
```

### Stripe Checkout Flow ‚úÖ UPDATED
**Simplified checkout with Stripe defaults:**

```typescript
// Success: Uses Stripe default success page (no custom redirect)
// Cancel/Back: Redirects to /app/help for easy navigation
const session = await createCheckoutSession(
  userId,
  priceId,
  '', // Stripe default success page
  `${process.env.NEXT_PUBLIC_BETTER_AUTH_URL}/app/help` // Back button
);
```

### User Experience Patterns ‚úÖ IMPLEMENTED

**Settings Modal Layout:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Settings            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Report Frequency            ‚îÇ 
‚îÇ ‚óã Weekly  ‚óè Monthly         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Auto Rephrase              ‚îÇ
‚îÇ ‚òë Enable automatic rephrase ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Billing & Subscription      ‚îÇ
‚îÇ Current Plan: Pro - $10/mo  ‚îÇ
‚îÇ (active)                    ‚îÇ
‚îÇ         [Manage Billing] ‚Üê‚îÄ‚îÄ‚î§ Opens in new tab
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           [Save]            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Conditional Button Logic:**
- **FREE users**: Blue "Upgrade to Pro" button ‚Üí Stripe Checkout
- **PRO users**: Gray "Manage Billing" button ‚Üí Stripe Customer Portal
- **Modal persistence**: Settings modal stays open after billing button click

### Subscription Validation Patterns ‚úÖ UPDATED
**Simplified rate limiting (no unlimited `-1` values):**

```typescript
// All features now have numeric limits
const accessCheck = await validateUserAccess(userId, 'personalFeedback');
if (!accessCheck.allowed) {
  if (accessCheck.upgradeRequired) {
    return generateUpgradeMessage('personalFeedback', accessCheck.reason, accessCheck.user?._id);
  }
  return generateLimitReachedMessage('personalFeedback', currentUsage, limit, resetDate, accessCheck.user?._id);
}
```

### Error Handling Patterns ‚úÖ IMPLEMENTED
- **ObjectId Conversion**: Always use `.toString()` for Stripe operations
- **Database Queries**: Always use `new ObjectId()` for MongoDB operations  
- **Button Styling**: Use conditional styling (no `'default'` style, only `'primary'` or omit)
- **Webhook Processing**: Handle MongoDB ObjectId strings from Stripe metadata

## Comprehensive Logging & Error Tracking ‚úÖ IMPLEMENTED

### Logging Architecture
- **Logger Utility**: [src/lib/logger.ts](mdc:src/lib/logger.ts) - Structured logging with INFO, WARN, ERROR, DEBUG levels
- **PostHog Integration**: [src/lib/posthog.ts](mdc:src/lib/posthog.ts) - Server-side error and event tracking
- **Client Analytics**: [src/hooks/useAnalytics.ts](mdc:src/hooks/useAnalytics.ts) - Renamed to `usePostHog` for direct usage

### Mandatory Error Tracking Pattern ‚úÖ ENFORCED
**Every API route MUST have comprehensive error tracking:**

```typescript
} catch (error) {
    const errorObj = error instanceof Error ? error : new Error(String(error));
    
    // Structured logging for developers
    logError('Descriptive error message', errorObj, { 
        endpoint: '/api/route/path',
        user_id: userId,
        operation: 'specific_operation'
    });
    
    // PostHog analytics for business insights
    trackError(userId || 'anonymous', errorObj, { 
        endpoint: '/api/route/path',
        operation: 'specific_operation',
        context: 'additional_context'
    });
    
    return NextResponse.json({ error: 'User-friendly message' }, { status: 500 });
}
```

### Success Operation Logging ‚úÖ IMPLEMENTED
**Track successful operations with info logs:**

```typescript
logInfo('Operation completed successfully', { 
    user_id: userId,
    endpoint: '/api/route/path',
    operation: 'specific_operation',
    // Additional success context...
});
```

### Event Tracking Rules ‚úÖ UPDATED
- **Use centralized events**: All event names in [src/lib/analytics/events.ts](mdc:src/lib/analytics/events.ts)
- **Follow naming convention**: `category:object_action` format (e.g., `feature:auto_coaching_triggered`)
- **AUTO_COACHING_TRIGGERED**: Only fire when rephrased message is actually sent to user
- **No skipped events**: Don't track when no action is taken

### Logging Levels Usage
- **INFO**: Successful operations, user journeys, business metrics
- **WARN**: Recoverable issues, deprecation warnings
- **ERROR**: Failures, exceptions, critical issues requiring attention
- **DEBUG**: Development debugging, detailed flow tracing

### Required Imports for API Routes
```typescript
// Standard logging imports for all API routes
import { logError, logInfo } from '@/lib/logger';
import { trackError, trackEvent } from '@/lib/posthog';
import { EVENTS } from '@/lib/analytics/events';
```

---
_Use this snapshot alongside the guidelines above to maintain consistency and avoid duplicating functionality._