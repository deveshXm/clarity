---
alwaysApply: true
---

# Your role
You are an award winning app designer & developer. Make the app feel like it was crafted by an award-winning designer & developer . Ultra-modern, playful, highly usable, with smooth microinteractions and delightful UX touches that elevate the entire experience.

When you write code, ensure it is clean, minimal, and easy to read. Avoid unnecessary functions or complexity. Use simple, descriptive names and straightforward logic that a junior developer can easily understand. Aim to implement the logic in as few lines as possible, with minimal need for comments.

# Project Guidelines

## App Identity & Naming
- **App Name**: Generic boilerplate - use "Your App" or similar generic names
- **Database Naming**: Use environment variable `MONGODB_DB_NAME` for database name
- **Consistency**: Keep branding generic and customizable
- **Case Usage**: 
  - UI/Display: Generic names like "Your App" (capitalized)
  - Database/Technical: Use environment variables
  - File names: Follow existing conventions (kebab-case, camelCase as appropriate)

## File Organization
- **Minimize file creation**: Do not create unnecessary files
- **Single file approach**: Keep related functionality in single files where it makes sense
- **Consolidate similar code**: Use index files to group related exports
- **Examples**:
  - All types in [src/types/index.ts](mdc:src/types/index.ts)
  - All hooks in [src/hooks/index.ts](mdc:src/hooks/index.ts)
  - All context providers in [src/context/index.tsx](mdc:src/context/index.tsx)

## Component Organization
- **Common components only**: Only keep components in [src/components/](mdc:src/components) that are common or can be used by multiple different pages
- **Page-specific components**: Keep components that are specific to a particular page in the same folder as the page in the app directory for easy accessibility and clarity
- **Co-location principle**: Components used by only one page should live next to that page, not in the global components folder

## Development Approach
- **Only do what's requested**: Do not add extra features or functionality unless explicitly asked
- **Ask for permission**: If you want to add something extra, always ask for permission first
- **Follow up questions**: If confused about requirements, ask clarifying questions
- **Stay focused**: Complete the specific task requested before suggesting improvements

## Build Quality & Error Prevention
- **JSX Entity Escaping**: Always escape special characters in JSX text content to prevent React unescaped entity errors
  - Use `&apos;` for apostrophes: `you'll` ‚Üí `you&apos;ll`
  - Use `&ldquo;` and `&rdquo;` for quotes: `"quoted text"` ‚Üí `&ldquo;quoted text&rdquo;`
  - Use `&amp;` for ampersands: `A & B` ‚Üí `A &amp; B`
- **TypeScript Parameter Usage**: Remove unused parameters from function signatures instead of prefixing with underscore
  - ‚ùå WRONG: `function handleData(_unusedParam: string, data: string)`
  - ‚úÖ CORRECT: `function handleData(data: string)` and update all calls
- **Type Safety**: Never use `any` type - always provide explicit type annotations
  - ‚ùå WRONG: `const params: any = { channel: id };`
  - ‚úÖ CORRECT: `const params: { channel: string; limit?: number } = { channel: id };`
- **Suspense Boundaries**: Wrap components using `useSearchParams()` or other client-side hooks in Suspense boundaries
  - Always wrap in `<Suspense fallback={LoadingComponent}>` when using `useSearchParams()`, `useRouter()` with client-side navigation
  - Provide meaningful loading fallbacks for better UX
- **ESLint Compliance**: Follow all ESLint rules without exceptions - fix issues rather than disable rules
- **Build Verification**: Always run `npm run build` before completing tasks to ensure no build errors

## Framework-First Approach
- **Next.js 15** - we are using nextjs 15 version
- **Use Next.js built-ins**: Always use Next.js default features like `loading.tsx`, `error.tsx`, and `not-found.tsx` for handling loading states, errors, and 404s instead of custom logic
- **Check before creating**: Always check if a component, hook, or utility already exists in the framework or codebase before creating a new one
- **Ask before building**: Must ask permission before creating new components, utilities, or logic that might already exist in the framework
- **Leverage defaults**: Prefer Next.js conventions (file-based routing, built-in components) over custom implementations

## Code Duplication Prevention
- **Check before creating**: Always search existing codebase before creating new functions, types, or database operations
- **Search locations**:
  - Functions: Check [src/lib/](mdc:src/lib), [src/hooks/index.ts](mdc:src/hooks/index.ts), and relevant component files
  - Types: Check [src/types/index.ts](mdc:src/types/index.ts) first
  - Database operations: Check [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) first
- **Reuse over recreation**: If similar functionality exists, extend or modify rather than duplicate

## UI Component Architecture
- **Mantine as base**: Always use Mantine library components as the foundation
- **Wrapper pattern**: Create wrapper components in [src/components/ui/](mdc:src/components/ui) to prevent vendor lock-in
- **NEVER use Mantine directly**: NEVER import or use Mantine components directly in any application code. ALL Mantine components must be wrapped in UI components first
- **UI components only**: Always import components from `@/components/ui` - never from `@mantine/core` or any other UI library
- **Forward refs**: Always use `forwardRef` for UI components to maintain ref compatibility
- **Export pattern**: Export wrapped components from [src/components/ui/index.ts](mdc:src/components/ui/index.ts)
- **Next.js components**: Wrap Next.js components (Link, Image, etc.) with custom components using `forwardRef` to maintain fixed values and consistency
- **Example structures**:
  ```typescript
  // ‚ùå WRONG - Never do this
  import { Button, Text, Stack } from '@mantine/core';
  
  // ‚úÖ CORRECT - Always do this
  import { Button, Text, Stack } from '@/components/ui';
  
  // src/components/ui/Button.tsx
  import { Button as MantineButton } from '@mantine/core';
  import { forwardRef } from 'react';
  
  export const Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
    return <MantineButton ref={ref} {...props} />;
  });
  
  // src/components/ui/Link.tsx
  import NextLink from 'next/link';
  import { forwardRef } from 'react';
  
  export const Link = forwardRef<HTMLAnchorElement, LinkProps>((props, ref) => {
    return <NextLink ref={ref} prefetch={false} {...props} />;
  });
  ```

## Mantine UI Setup

### Configuration Files
- **Theme Configuration**: [src/lib/theme.ts](mdc:src/lib/theme.ts) - Professional color palette with primary blue, secondary teal, accent orange, and status colors
- **PostCSS Setup**: [postcss.config.cjs](mdc:postcss.config.cjs) - Mantine preset and responsive breakpoint variables
- **Layout Integration**: [src/app/layout.tsx](mdc:src/app/layout.tsx) - MantineProvider, ColorSchemeScript, and theme application
- **Next.js Optimization**: [next.config.ts](mdc:next.config.ts) - Package import optimization for Mantine components

### Usage
- Always use theme colors from [src/lib/theme.ts](mdc:src/lib/theme.ts) instead of arbitrary colors
- Components are pre-configured with professional defaults (radius, shadows, sizes)
- Follow UI component architecture rules for creating wrapper components

## UI Components Inventory

### Core UI Components
- **Button** - [src/components/ui/Button.tsx](mdc:src/components/ui/Button.tsx) - Basic button wrapper with forwardRef
- **LoadingButton** - [src/components/ui/LoadingButton.tsx](mdc:src/components/ui/LoadingButton.tsx) - Button with built-in loading states and Lucide icons
- **TextInput** - [src/components/ui/TextInput.tsx](mdc:src/components/ui/TextInput.tsx) - Text input wrapper
- **Textarea** - [src/components/ui/Textarea.tsx](mdc:src/components/ui/Textarea.tsx) - Textarea wrapper
- **Card** - [src/components/ui/Card.tsx](mdc:src/components/ui/Card.tsx) - Card wrapper
- **AnimatedCard** - [src/components/ui/AnimatedCard.tsx](mdc:src/components/ui/AnimatedCard.tsx) - Card with hover and click animations
- **LoadingOverlay** - [src/components/ui/LoadingOverlay.tsx](mdc:src/components/ui/LoadingOverlay.tsx) - Loading overlay wrapper

### Layout Components
- **Container** - [src/components/ui/Container.tsx](mdc:src/components/ui/Container.tsx) - Container wrapper
- **Stack** - [src/components/ui/Stack.tsx](mdc:src/components/ui/Stack.tsx) - Stack layout wrapper
- **Center** - [src/components/ui/Center.tsx](mdc:src/components/ui/Center.tsx) - Center alignment wrapper

### Typography Components
- **Title** - [src/components/ui/Title.tsx](mdc:src/components/ui/Title.tsx) - Title/heading wrapper
- **Text** - [src/components/ui/Text.tsx](mdc:src/components/ui/Text.tsx) - Text wrapper

### Navigation Components
- **Link** - [src/components/ui/Link.tsx](mdc:src/components/ui/Link.tsx) - Next.js Link wrapper with fixed prefetch=false

### Form Components
- **FormField** - [src/components/ui/FormField.tsx](mdc:src/components/ui/FormField.tsx) - Reusable form field with label, description, and error handling
- **ErrorMessage** - [src/components/ui/ErrorMessage.tsx](mdc:src/components/ui/ErrorMessage.tsx) - Error alert with Lucide AlertCircle icon
- **SuccessMessage** - [src/components/ui/SuccessMessage.tsx](mdc:src/components/ui/SuccessMessage.tsx) - Success alert with Lucide CheckCircle icon

### Loading Components
- **Skeleton** - [src/components/ui/Skeleton.tsx](mdc:src/components/ui/Skeleton.tsx) - Basic skeleton wrapper
- **FormSkeleton** - [src/components/ui/FormSkeleton.tsx](mdc:src/components/ui/FormSkeleton.tsx) - Specialized skeleton for forms with configurable fields

### Animation Components
- **FadeIn** - [src/components/ui/FadeIn.tsx](mdc:src/components/ui/FadeIn.tsx) - Smooth fade-in animation with customizable delay and duration
- **AnimatedCard** - Already listed above in Core UI Components

### Component Export Index
- **All components exported from**: [src/components/ui/index.ts](mdc:src/components/ui/index.ts)

### Usage Guidelines for UI Components
- **Import pattern**: Always import from the index file: `import { Button, TextInput } from '@/components/ui';`
- **Lucide icons**: All icon components use Lucide React icons (pre-installed)
- **ForwardRef compatibility**: All components support ref forwarding
- **TypeScript types**: All components export proper TypeScript interfaces/types
- **Mantine foundation**: All components wrap Mantine components to prevent vendor lock-in

## Color Scheme Management
- **Use predefined colors only**: Never use random or hardcoded colors
- **Color source**: All colors must come from the established color scheme configuration
- **Configuration location**: Colors defined in theme/config files (to be determined)
- **No arbitrary colors**: Avoid using arbitrary Tailwind colors or CSS color values
- **Consistency**: Maintain visual consistency across all components and pages

## Database Architecture
- **Use Native MongoDB Driver**: The project uses MongoDB's native Node.js driver (not Mongoose)
- **Database Connection**: MongoDB client is configured in [src/lib/db.ts](mdc:src/lib/db.ts)
- **Database Name**: Use `process.env.MONGODB_DB_NAME` for database name
- **No ODM/ORM**: Direct MongoDB operations without abstraction layer
- **Server Actions**: All database operations should be in Server Actions in [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts)
- **Collection Operations**: Use native MongoDB collection methods (insertOne, findOne, updateOne, etc.)

## Authentication & Slack Integration Architecture
- **Slack OAuth**: Direct Slack app installation without traditional web authentication
- **Workspace-Specific Tokens**: Each workspace has its own bot token stored during OAuth installation
- **Bot Token Storage**: Workspace-specific `botToken` field in workspaceCollection enables per-workspace API calls
- **Channel Access Control**: Bot only operates in channels explicitly selected during onboarding
- **Authorization Strategy**: Simple database presence check - if user exists in database, they're authorized
- **Authentication Flow**:
  1. **Website Install**: User clicks "Install to Slack" ‚Üí OAuth ‚Üí Database entry ‚Üí Full access
  2. **Direct Install**: User installs from Slack App Directory ‚Üí OAuth ‚Üí Database entry ‚Üí Full access
  3. **Command Authorization**: If user NOT in database ‚Üí Show authorization message with website redirect
- **Token Usage**: All Slack API calls use workspace-specific tokens from database
- **No Web Sessions**: Standard Slack app approach - all data tied to Slack user IDs

## Slack Event Handling & Auto Coaching ‚úÖ IMPLEMENTED

### Event Subscription Strategy
- **Privacy by Design**: Bot only receives events from channels where it's explicitly added as a member
- **Event Types Required**: 
  - `message.channels` - Public channel messages (REQUIRED for auto coaching)  
  - `message.groups` - Private channel messages
  - `app_mention` - @bot mentions
- **Channel Filtering**: Slack automatically filters events to only channels where bot is member
- **Database Verification**: Additional check against `botChannelsCollection` for authorized channels

### Auto Coaching Implementation ‚úÖ WORKING
- **Real-time Analysis**: Message events trigger AI analysis for communication improvement
- **Ephemeral Feedback**: Private suggestions only visible to message sender
- **Interactive Components**: "Replace Message" and "Keep Original" buttons
- **Workspace-Specific Tokens**: Each workspace uses its own bot token for API calls
- **Channel Access Control**: Double-layer verification (Slack + database) ensures privacy

### Message Event Processing Flow
```typescript
// 1. Slack sends event (only from member channels)
if (event.type === 'message' && (event.channel_type === 'channel' || event.channel_type === 'group')) {
  
  // 2. Validate user has app installed
  const user = await slackUserCollection.findOne({ slackId: event.user, isActive: true });
  if (!user) return; // Skip - user hasn't installed app
  
  // 3. Verify bot is active in specific channel  
  const isChannelActive = await isChannelAccessible(event.channel, user.workspaceId);
  if (!isChannelActive) return; // Skip - not authorized channel
  
  // 4. Get workspace-specific bot token
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  if (!workspace?.botToken) return; // Skip - missing token
  
  // 5. AI analysis and ephemeral coaching feedback
  // 6. Interactive message replacement functionality
}
```

## Slack Scope Management & Troubleshooting ‚úÖ CRITICAL
- **Required Bot Scopes**: All Slack functionality depends on having correct bot token scopes configured
- **Scope Configuration Files**:
  - Code: [src/lib/slack.ts](mdc:src/lib/slack.ts) - `slackOAuthConfig.botScopes` array  
  - Manifest: [manifest.json](mdc:manifest.json) - `oauth_config.scopes.bot` array
- **Critical Scopes for Core Functionality**:
  - `chat:write` - Send messages to channels (REQUIRED)
  - `chat:write.customize` - Custom username/avatar for message replacement
  - `im:write` - Send direct messages to users (REQUIRED for welcome messages)
  - `message.channels` event subscription requires proper scopes
- **Common Issues Fixed**:
  - Missing `message.channels` in event subscriptions (prevented auto coaching)
  - Incorrect interactive endpoint URL (`/interactions` vs `/interactive`)
  - Missing `chat:write.customize` scope for message replacement
  - Using global bot token instead of workspace-specific tokens
- **Troubleshooting Process**:
  1. Check error logs for `missing_scope` messages
  2. Identify which API method is failing
  3. Look up required scopes in Slack API docs
  4. Add missing scopes to both `src/lib/slack.ts` and `manifest.json`
  5. Update Slack app configuration in developer console
  6. Reinstall app to get new permissions
- **Essential Bot Scopes List**:
  ```typescript
  botScopes: [
    'chat:write',        // Send messages
    'chat:write.public', // Send to channels bot isn't in
    'chat:write.customize', // Custom username/avatar for replacements
    'commands',          // Slash commands
    'channels:history',  // Read message history
    'groups:history',    // Read private channel history  
    'channels:read',     // Read channel info
    'channels:join',     // Join channels during onboarding
    'groups:read',       // Read private channel info
    'im:write',          // Send DMs (CRITICAL for welcome messages)
    'users:read',        // Read user info
    'app_mentions:read'  // Handle @mentions
  ]
  ```

## Welcome Message Implementation ‚úÖ COMPLETED
- **Functionality**: Personalized welcome message sent via DM after Slack app installation
- **Implementation**: [src/lib/slack.ts](mdc:src/lib/slack.ts) - `sendWelcomeMessage()` function
- **Integration**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts) - Called after OAuth success
- **Message Features**:
  - Rich Block Kit formatting with interactive buttons
  - "Complete Setup" button linking to onboarding
  - "Help Center" button for documentation  
  - Clear value proposition and next steps
  - Privacy reassurance (feedback is private)
- **Error Handling**: Graceful failure - doesn't break OAuth flow if DM fails
- **Critical Dependency**: Requires `im:write` scope for DM functionality
- **Follow-up System**: `sendOnboardingReminderMessage()` for incomplete users

## API Architecture
- **Use Server Actions**: Prefer Next.js Server Actions over API routes for most functionality
- **API routes only for**:
  - Slack OAuth callback and webhook endpoints
  - Slack commands, events, and interactive components
  - Webhook endpoints from external services
  - Third-party integrations that require traditional REST endpoints
- **Server Actions for**:
  - Database operations (with workspace-specific token lookups)
  - Form submissions and onboarding flow
  - Data mutations and channel management
  - Business logic and AI operations
- **Workspace Token Pattern**: Server actions fetch workspace-specific bot tokens from database before making Slack API calls

## Project Structure Reference
- **Auth pages**: [src/app/(auth)/](mdc:src/app/(auth)/) - Login, register, etc.
- **App pages**: [src/app/app/](mdc:src/app/app) - Protected application pages (no route group)
- **Public pages**: [src/app/(public)/](mdc:src/app/(public)/) - Landing and public pages
- **API routes**: [src/app/api/](mdc:src/app/api) - Only for auth and specific endpoints
- **Components**: [src/components/](mdc:src/components) - Organized by section (ui, auth, app, common)
- **Server Actions**: [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) for shared database operations

## Current Implementation Snapshot (January 2025)

_This snapshot helps you quickly navigate the existing codebase. It will become outdated as files change, so update it when major structural changes occur._

### Root Directories
- **Source code**: [src/](mdc:src)
  - **Application routes**: [src/app/](mdc:src/app)
  - **Shared libraries & helpers**: [src/lib/](mdc:src/lib)
  - **Global React context**: [src/context/](mdc:src/context) (currently empty)
  - **Reusable components**: [src/components/](mdc:src/components)
  - **Type definitions**: [src/types/](mdc:src/types)
  - **Custom hooks**: [src/hooks/](mdc:src/hooks)

### Key Route Groups
1. **Public Pages** ‚Äî [src/app/(public)/](mdc:src/app/(public)/) 
   - Landing page with Slack installation: [src/app/(public)/page.tsx](mdc:src/app/(public)/page.tsx)
   - Marketing and public content

2. **App Pages** ‚Äî [src/app/app/](mdc:src/app/app) (no auth needed - Slack app)
   - Onboarding flow: [src/app/app/onboarding/page.tsx](mdc:src/app/app/onboarding/page.tsx)
   - Help documentation: [src/app/app/help/page.tsx](mdc:src/app/app/help/page.tsx)  
   - Team invitations: [src/app/app/invite/page.tsx](mdc:src/app/app/invite/page.tsx)

3. **API Routes** ‚Äî [src/app/api/](mdc:src/app/api)
   - Slack OAuth callback: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts)
   - Slack commands: [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts)
   - Slack events: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts)

### Middleware & Authentication
- **Middleware**: [src/middleware.ts](mdc:src/middleware.ts) - Protects `/app/*` routes with session validation and onboarding flow
- **Auth Configuration**: [src/lib/auth.ts](mdc:src/lib/auth.ts) - Better-auth setup
- **Auth Client**: [src/lib/auth-client.ts](mdc:src/lib/auth-client.ts) - Browser-side auth utilities

### Library & Utility Files
- **MongoDB client**: [src/lib/db.ts](mdc:src/lib/db.ts) - Native MongoDB driver connection
- **Server actions**: [src/lib/server-actions.ts](mdc:src/lib/server-actions.ts) - Database operations and business logic
- **AI Integration**: [src/lib/ai.ts](mdc:src/lib/ai.ts) - Azure OpenAI powered AI functions for auto-coaching
- **AI Prompts**: [src/lib/prompts/index.ts](mdc:src/lib/prompts/index.ts) - Centralized AI prompt templates (includes contextual variants for rephrase)
- **Theme configuration**: [src/lib/theme.ts](mdc:src/lib/theme.ts)
- **Utilities**: [src/lib/utils.ts](mdc:src/lib/utils.ts)

### API Routes
- **Auth**: [src/app/api/auth/[...all]/route.ts](mdc:src/app/api/auth/[...all]/route.ts) - Better-auth handler
- **User**: [src/app/api/user/route.ts](mdc:src/app/api/user/route.ts) - User data endpoint for middleware

### UI Component Folders
- **UI wrappers**: [src/components/ui/](mdc:src/components/ui) - Comprehensive UI component library
- **Auth-specific components**: [src/components/auth/](mdc:src/components/auth) (currently empty)

### Data & Types
- **Type definitions**: [src/types/index.ts](mdc:src/types/index.ts) - Simplified Zod schemas and TypeScript types
- **No Mongoose Models**: Database operations use native MongoDB driver with Zod schemas for validation

### Styling & Theme
- **Global CSS**: [src/app/globals.css](mdc:src/app/globals.css)
- **Mantine Provider & fonts**: [src/app/layout.tsx](mdc:src/app/layout.tsx)

## Validation & Schema Management
- **Use Zod for validation**: Always use Zod schemas for data validation instead of manual checking
- **Schema location**: Define Zod schemas in [src/types/index.ts](mdc:src/types/index.ts) alongside TypeScript interfaces
- **Validation pattern**: Create Zod schemas that can infer TypeScript types, ensuring single source of truth
- **Server actions**: Use Zod schemas to validate inputs in server actions before processing
- **Form validation**: Use Zod schemas with form libraries for client-side validation
- **API validation**: Validate all incoming data using Zod schemas
- **Database validation**: Use Zod schemas to validate data before MongoDB operations
- **Example pattern**:
  ```typescript
  // Define Zod schema first
  export const UserConfigSchema = z.object({
    websiteUrl: z.string().url(),
    companyName: z.string().min(1),
    // ... other fields
  });
  
  // Infer TypeScript type from schema
  export type UserConfig = z.infer<typeof UserConfigSchema>;
  
  // Use in MongoDB operations
  const validatedData = UserConfigSchema.parse(rawData);
  await db.collection('configs').insertOne(validatedData);
  ```

## Onboarding Flow Implementation ‚úÖ COMPLETED
- **Multi-step form**: [src/app/app/onboarding/OnboardingForm.tsx](mdc:src/app/app/onboarding/OnboardingForm.tsx) handles Slack user onboarding
- **User Identification**: Query parameters (`?user={slackId}&team={teamId}`) for validation
- **Step 1**: Analysis frequency selection (weekly/monthly)
- **Step 2**: Channel selection - users choose which channels to enable AI coaching
- **Step 3**: Team member email invitations (optional)
- **Server Actions**: 
  - `validateSlackUser()` - Validates user and checks onboarding status
  - `getWorkspaceChannels()` - Fetches available channels using workspace-specific bot token
  - `saveBotChannels()` - Joins bot to selected channels and stores in database
  - `completeSlackOnboarding()` - Saves preferences, channels, and marks onboarding complete
- **One-time completion**: `hasCompletedOnboarding` flag prevents re-access
- **Bot Integration**: Bot automatically joins selected channels during onboarding
- **Completion**: Sets `hasCompletedOnboarding: true` on user document for middleware routing

## Key Collections ‚úÖ UPDATED
- **workspaceCollection**: Slack workspace/team data (workspaceId, name, domain, **botToken**)
- **slackUserCollection**: Slack user data with onboarding tracking (slackId, analysisFrequency, hasCompletedOnboarding)
- **botChannelsCollection**: Tracks which channels bot is active in (workspaceId, channelId, channelName, addedAt)
- **invitationCollection**: Email invitations sent by users during onboarding
- **analysisInstanceCollection**: Future - will store message analysis results
- **Legacy collections**: userCollection, accountConfigCollection (for reference only)

## Trigger.dev Background Jobs Architecture

### What is Trigger.dev?
**Trigger.dev** is a powerful background job and AI infrastructure platform that enables developers to write reliable, long-running workflows in normal async code. It handles queues, elastic scaling, retries, observability, and zero infrastructure management.

**Key Features:**
- **No timeouts**: Write simple, reliable code that never hits timeouts
- **Pay for what you use**: Only pay when code is actually executing
- **No servers to manage**: Automatic deployment and scaling
- **Observability**: Real-time monitoring and tracing of tasks
- **Retries**: Automatic retrying with configurable strategies
- **AI integration**: Built-in support for AI agents and LLM workflows

**Documentation**: [https://trigger.dev/docs](https://trigger.dev/docs)

### Project Integration

#### Configuration
- **Config file**: [trigger.config.ts](mdc:trigger.config.ts) - Main Trigger.dev configuration
- **Task location**: [src/trigger/](mdc:src/trigger/) - All background tasks
- **Environment variables**: Use `TRIGGER_API_KEY` and `TRIGGER_API_URL` for deployment

#### Task Structure
```typescript
// Example task pattern
import { task } from "@trigger.dev/sdk/v3";

export const exampleTask = task({
  id: "example-task",
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 5000,
  },
  run: async (payload, { ctx }) => {
    // Your async logic here
    console.log("Task executed:", payload);
    
    return { success: true, data: "Task completed" };
  },
});
```

#### Current Implementation
- **Generic task**: [src/trigger/generateCreative.ts](mdc:src/trigger/generateCreative.ts) - Simplified example task
- **Task ID**: Uses environment variable `TRIGGER_TASK_ID` for generic naming
- **Purpose**: Demonstrates basic Trigger.dev integration pattern

#### Best Practices
- **Task naming**: Use descriptive, generic names that can be reused
- **Error handling**: Implement proper error handling with retry logic
- **Payload validation**: Validate input payloads using Zod schemas
- **Logging**: Use structured logging for observability
- **Environment separation**: Use different task IDs for dev/prod environments

#### Common Use Cases
- **AI workflows**: Long-running AI operations with LLM chains
- **Data processing**: Batch operations and ETL processes
- **Scheduled tasks**: Cron jobs and periodic operations
- **Webhook processing**: Handle external service webhooks
- **Email campaigns**: Bulk email processing and delivery
- **File processing**: Image, video, and document processing

#### Development Workflow
1. **Local development**: Use Trigger.dev CLI for local testing
2. **Task deployment**: Deploy tasks to Trigger.dev cloud
3. **Monitoring**: Use Trigger.dev dashboard for observability
4. **Debugging**: Use run logs and tracing for troubleshooting

#### Integration with Next.js
- **Server Actions**: Trigger tasks from server actions
- **API Routes**: Use for webhook endpoints that trigger tasks
- **Client-side**: Use Trigger.dev React hooks for real-time updates
- **Environment**: Configure for different deployment environments

## Azure OpenAI Integration ‚úÖ IMPLEMENTED

### Configuration
- **Provider**: Azure OpenAI using official `openai` SDK with `AzureOpenAI` client
- **Environment Variables**:
  - `AZURE_API_KEY` - Azure OpenAI API key (required)
  - `AZURE_API_ENDPOINT` - Azure endpoint URL (required)
  - `AZURE_API_VERSION` - API version (defaults to '2024-12-01-preview')
  - `AZURE_DEPLOYMENT_NAME` - Model deployment name (defaults to 'gpt-4')
  - `AZURE_MODEL_NAME` - Optional model name override

### AI Architecture ‚úÖ OPTIMIZED
- **Client Setup**: [src/lib/ai.ts](mdc:src/lib/ai.ts) - Single `AzureOpenAI` client instance
- **Prompt Management**: [src/lib/prompts/index.ts](mdc:src/lib/prompts/index.ts) - Centralized prompt templates with GPT-5 best practices
- **JSON Response Format**: All AI functions use `response_format: { type: 'json_object' }` with explicit JSON instructions
- **Performance Config**: `reasoning_effort: 'low'` for optimized speed vs. quality balance
- **Model**: GPT-5 (or gpt-5-nano) via Azure OpenAI deployment

### Auto-Coaching Workflow ‚úÖ OPTIMIZED (Single AI Call)
1. **Step 1: Always Fetch Context** - Get conversation history for better analysis
   - Fetch last 15 messages from Slack API for all messages
   - Provides context for more accurate analysis

2. **Step 2: Comprehensive Analysis** - Single AI call handles everything
   - Uses `comprehensiveMessageAnalysis()` - one AI call replaces 4 separate calls
   - Performs screening, detailed analysis, target identification, and message improvement
   - **75% faster** and **75% cheaper** than previous multi-call approach

3. **Step 3: Send Coaching** - Only if issues found
   - Ephemeral feedback with improved message suggestions
   - Interactive buttons for message replacement

### AI Functions Implemented
**Auto-Coaching (Optimized):**
- **`comprehensiveMessageAnalysis()`** - Single AI call for complete analysis (NEW)

**Manual Commands (Preserved):**
- **`analyzeMessageForFlags()`** - Detailed analysis with context (for `/personalfeedback`)
- **`analyzeMessageForRephraseWithoutContext()`** - Context-free analysis for `/rephrase`
- **`analyzeMessageForRephraseWithContext()`** - Context-aware analysis for `/rephrase`
- **`generateImprovedMessage()`** - Basic message improvements for `/rephrase`
- **`generateImprovedMessageWithContext()`** - Context-aware improvements for `/rephrase`
- **`generatePersonalFeedback()`** - User communication patterns analysis
- **`generateReport()`** - Weekly/monthly communication reports

**Legacy Functions (Removed):**
- ~~`quickCheckNeedsCoaching()`~~ - Replaced by comprehensive analysis
- ~~`identifyMessageTarget()`~~ - Integrated into comprehensive analysis

### Prompt Design Principles ‚úÖ UPDATED (GPT-5 Best Practices)
- **Conservative by default** - Don't flag normal professional communication
- **Explicit JSON format** - Required for Azure OpenAI `json_object` mode
- **Context separation** - Clear distinction between current message and history
- **Specific examples** - Concrete examples of what to flag/not flag
- **Tone adaptation** - Match user's tone, register, and formality in improvements
- **Human-like output** - Avoid AI-ish phrasing, hedging, or generic filler
- **Slack-specific preservation** - Keep @mentions, <#channel> references, links, code
- **Natural length** - Keep approximately same length unless brevity obviously helps

### Contextual Analysis Patterns ‚úÖ NEW
- **Conditional Context Usage**: `/rephrase` command intelligently uses conversation history when bot has channel access
- **Channel Access Detection**: Uses `isChannelAccessible()` to determine if bot can fetch conversation history
- **Dual Analysis Paths**:
  - **With Context**: `analyzeMessageForRephraseWithContext()` - Uses last 10 messages for better understanding
  - **Without Context**: `analyzeMessageForRephraseWithoutContext()` - Analyzes only the provided message text
- **Context-Aware Improvements**: `generateImprovedMessageWithContext()` creates suggestions that fit conversation flow
- **Privacy-First**: Only accesses conversation data when bot is explicitly added to channels

---
_Use this snapshot alongside the guidelines above to maintain consistency and avoid duplicating functionality._

## Slack Slash Command Modal Responses
- When a slash command opens a modal via `views.open`, **never** wait for the API call to resolve before responding to Slack.
- Respond with an **empty 200 OK** (no JSON body) or `null` in Next.js API routes to acknowledge the request immediately.
- This prevents Slack from posting a `Slackbot` operation_timeout error or showing "We had some trouble connecting" banners.
- Handle any async work (e.g., DB updates, secondary API calls) in the background and log errors instead of blocking the response.

## Using `after()` for background tasks (Next.js 15)
- When running on Vercel, prefer Next.js `after()` from `next/server` to schedule any asynchronous work (DB writes, external API calls, logging) **after** the HTTP response has been sent.
- Pattern:
  ```ts
  import { after } from 'next/server';

  // inside route handler
  after(async () => {
    await doLongTask();
  });

  return new Response(null, { status: 200 });
  ```
- This guarantees the work completes (or errors) without risking Slack‚Äôs 3-second timeout and without dropping promises when the serverless invocation ends.
- Continue to respond to Slack immediately (empty 200 or minimal JSON) before the 3-second window.

## Enhanced Rephrase Command Implementation ‚úÖ COMPLETED

### Contextual Analysis Workflow
The `/rephrase` command now intelligently adapts based on bot channel permissions:

**Implementation Pattern:**
```typescript
// Check if bot has channel access
const hasChannelAccess = await isChannelAccessible(channelId, user.workspaceId);

if (hasChannelAccess) {
    // Fetch last 10 messages for context
    const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 10);
    // Use context-aware analysis
    const analysisResult = await analyzeMessageForRephraseWithContext(text, conversationHistory);
    // Generate context-aware improvements
    const improvedMessage = await generateImprovedMessageWithContext(text, primaryFlag.type, conversationHistory);
} else {
    // Analyze without context
    const analysisResult = await analyzeMessageForRephraseWithoutContext(text);
    // Generate basic improvements
    const improvedMessage = await generateImprovedMessage(text, primaryFlag.type);
}
```

### Key Features ‚úÖ IMPLEMENTED
- **Conditional Context Fetching**: Only fetches conversation history when bot is channel member
- **Timeout Prevention**: Uses `after()` for background AI processing, responds immediately
- **Ephemeral Results**: Shows suggestions as private ephemeral messages in same channel
- **Clean Interface**: Simple format with original, improved, and tone information
- **Privacy-First**: Conversation history only accessed when explicitly authorized

### User Experience
1. User runs `/rephrase Can you get this done ASAP?`
2. Immediate response: "‚è≥ Analyzing and rephrasing your message..."
3. Background analysis completes (context-aware if bot in channel)
4. Ephemeral result shows improved message with tone information

## User Settings & Preferences ‚úÖ IMPLEMENTED

### Settings Command Implementation
- **Command**: `/settings` - Opens modal for user preference management
- **Modal Interface**: Clean, unified settings modal with two main options
- **Settings Available**:
  - **Report Frequency**: Weekly or Monthly (radio buttons)
  - **Auto Rephrase**: Enable/disable automatic coaching suggestions (checkbox)

### Settings Modal Design
- **No Current Settings Display**: Modal shows only the input controls
- **Simplified Labels**: "Auto Rephrase" (not "Auto Rephrase Suggestions")
- **Clean Interface**: No dividers or current status text
- **Help Text**: Context about manual `/rephrase` command when auto is disabled

### Settings Persistence
- **Database Field**: `autoRephraseEnabled: boolean` in SlackUser schema (default: true)
- **Immediate Update**: Settings saved in background using `after()` for fast response
- **Success Feedback**: Modal updates to show "‚úÖ Settings updated" message
- **Modal Behavior**: Stays open after save, user closes manually

### Auto Coaching Control
- **Preference Check**: Auto coaching respects `autoRephraseEnabled` setting
- **Event Processing**: Skip analysis if `user.autoRephraseEnabled === false`
- **Manual Override**: `/rephrase` command always works regardless of auto setting
- **Default Behavior**: New users get auto coaching enabled by default

### Implementation Files
- **Settings Modal**: [src/app/api/slack/commands/route.ts](mdc:src/app/api/slack/commands/route.ts) - `/settings` command handler
- **Settings Handler**: [src/app/api/slack/interactive/route.ts](mdc:src/app/api/slack/interactive/route.ts) - Modal submission processing
- **Auto Coaching Check**: [src/app/api/slack/events/route.ts](mdc:src/app/api/slack/events/route.ts) - Preference validation
- **User Creation**: [src/app/api/auth/slack/callback/route.ts](mdc:src/app/api/auth/slack/callback/route.ts) - OAuth with default settings

## Slack Integration Best Practices ‚úÖ CRITICAL UPDATES

### Workspace-Specific Token Usage Pattern ‚úÖ MANDATORY
**Never use global bot tokens - always use workspace-specific tokens from database:**

```typescript
// ‚ùå WRONG - Global token causes auth errors
const conversationHistory = await fetchConversationHistory(channelId, process.env.SLACK_BOT_TOKEN!, undefined, 40);

// ‚úÖ CORRECT - Workspace-specific token
const user = await slackUserCollection.findOne({ slackId: userId, isActive: true });
const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 40);
```

**Why this matters:**
- Each workspace has its own bot token from OAuth installation
- Global tokens cause `invalid_auth` errors in multi-workspace environments  
- Workspace-specific tokens ensure proper permissions and isolation

### Slack Markdown Formatting ‚úÖ CRITICAL
**Use Slack's mrkdwn format, not standard Markdown:**

```typescript
// ‚ùå WRONG - Standard Markdown (doesn't render in Slack)
const message = `**Personal Communication Feedback**\n**Overall Score**: 8/10\n*Analysis based on recent messages.*`;

// ‚úÖ CORRECT - Slack mrkdwn format
const message = `*Personal Communication Feedback*\n*Overall Score*: 8/10\n_Analysis based on recent messages._`;
```

**Slack formatting rules:**
- **Bold**: Use `*text*` (single asterisks)
- **Italic**: Use `_text_` (underscores)  
- **Code**: Use backticks `` `code` ``
- **Channels**: Use `<#channelId>` for channel references
- **Users**: Use `<@userId>` for user mentions

### Human-Only Message Filtering ‚úÖ IMPLEMENTED
**Enhanced conversation history filtering to only include human messages:**

```typescript
// In fetchConversationHistory - comprehensive filtering
const messages = result.messages
  .filter(msg => {
    // Must have text content
    if (!msg.text || msg.text.trim() === '') return false;
    
    // Filter out all bot messages
    if (msg.bot_id || msg.app_id) return false;
    
    // Filter out system messages by subtype
    if (msg.subtype && [
      'bot_message', 'channel_join', 'channel_leave', 'channel_topic',
      'channel_purpose', 'file_share', 'slackbot_response'
    ].includes(msg.subtype)) return false;
    
    // Must have a human user ID (starts with 'U')
    if (!msg.user || !msg.user.startsWith('U')) return false;
    
    // Filter out slash commands and standalone mentions
    const text = msg.text.trim();
    if (text.startsWith('/') || text.match(/^<@[UW][A-Z0-9]+>$/)) return false;
    
    return true;
  })
  .map(msg => msg.text || '')
  .reverse(); // Chronological order
```

### Background Processing with Timeout Prevention ‚úÖ IMPLEMENTED
**Slack command pattern with immediate response and background analysis:**

```typescript
// Personal feedback command example
async function handlePersonalFeedback(userId: string, channelId: string) {
  // Get user and workspace information
  const user = await slackUserCollection.findOne({ slackId: userId, isActive: true });
  const workspace = await workspaceCollection.findOne({ _id: new ObjectId(user.workspaceId) });
  
  // Schedule background analysis using after()
  after(async () => {
    try {
      // Heavy analysis work (conversation history + AI)
      const conversationHistory = await fetchConversationHistory(channelId, workspace.botToken, undefined, 40);
      const feedback = await generatePersonalFeedback(conversationHistory);
      
      // Add relationship insights
      const relationshipInsights = await analyzeRelationshipContext(conversationHistory);
      
      // Send formatted results via DM
      const formattedMessage = formatPersonalFeedbackMessage(feedback, relationshipInsights, channelId);
      await sendDirectMessage(userId, formattedMessage, workspace.botToken);
    } catch (error) {
      await sendDirectMessage(userId, 'Error generating report', workspace.botToken);
    }
  });

  // Immediately return processing message 
  return {
    text: '‚è≥ *Analyzing your communication patterns...*\n\nI\'ll send the detailed analysis to your DMs shortly!',
    response_type: 'ephemeral'
  };
}
```

### Relationship-Specific Coaching Insights ‚úÖ IMPLEMENTED
**Analyze individual messages to identify communication targets:**

```typescript
// Analyze recent messages for relationship context
let relationshipInsights: { name: string; issues: string[] }[] = [];
const relationshipMap = new Map<string, string[]>();

for (const message of recentMessages) {
  const analysis = await analyzeMessageForFlags(message, conversationHistory);
  if (analysis.flags.length > 0 && analysis.target?.name) {
    const issues = relationshipMap.get(analysis.target.name) || [];
    analysis.flags.forEach(flag => {
      if (!issues.includes(flag.type)) issues.push(flag.type);
    });
    relationshipMap.set(analysis.target.name, issues);
  }
}

// Only show if we have real person names (not "Unknown")
if (relationshipInsights.some(insight => insight.name && insight.name !== 'Unknown')) {
  feedbackMessage += `üë• *Relationship insights:*\n`;
  feedbackMessage += relationshipInsights
    .filter(insight => insight.name !== 'Unknown')
    .map(insight => `‚Ä¢ Work on *${insight.issues.join(', ')}* when messaging *${insight.name}*`)
    .join('\n');
}
```

### Friendly Coaching Tone ‚úÖ IMPLEMENTED
**Use supportive, personal language instead of formal reports:**

```typescript
// ‚ùå FORMAL - Sounds like a report
const responseText = `Communication Report\nOverall Score: 8/10\nAreas for Improvement:\n‚Ä¢ Be more specific`;

// ‚úÖ COACHING - Friendly and supportive
const responseText = `ü§ñ *Hey there! Here's your personal feedback*\n` +
  `*How you're doing: ${score}/10* ${score >= 8 ? 'üü¢ You\'re crushing it!' : 'üî¥ Let\'s level up together!'}\n` +
  `üí™ *Let's work on these together:*\n‚Ä¢ Be more specific in your requests`;
```

**Coaching language patterns:**
- "Hey there!" instead of formal greetings
- "How you're doing" instead of "Overall Score"  
- "Let's work on these together" instead of "Areas for Improvement"
- "Here's what I'd love to see you try next" instead of "Action Items"
- Encouraging emojis and supportive tone throughout


---
_Use this snapshot alongside the guidelines above to maintain consistency and avoid duplicating functionality._